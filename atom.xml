<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Now And Tomorrow</title>
  
  <subtitle>B站不再是“净土”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-08T12:25:25.843Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>方鹏程</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo几个命令</title>
    <link href="http://yoursite.com/2019/12/01/hello-world/"/>
    <id>http://yoursite.com/2019/12/01/hello-world/</id>
    <published>2019-12-01T10:45:29.000Z</published>
    <updated>2019-05-08T12:25:25.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      呵呵
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>vue动态路由</title>
    <link href="http://yoursite.com/2019/05/12/vue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2019/05/12/vue动态路由/</id>
    <published>2019-05-12T14:13:17.000Z</published>
    <updated>2019-05-13T14:30:32.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue-动态路由"><a href="#vue-动态路由" class="headerlink" title="vue 动态路由"></a>vue 动态路由</h1><h2 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h2><p>每配置router-link跳转，就在main.js中配置一次路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&apos;/content/&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">import content from &apos;./components/content.vue&apos;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &apos;/content/:id&apos;, component: content &#125;</span><br><span class="line">这就是动态路由，参数不同都能传到同一个路由即/content中，可以获取不同的参数，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mounted()&#123;//模板渲染完成之后触发的事件，f5刷新触发的事件</span><br><span class="line"></span><br><span class="line">          /* console.log(this.$route.params);  获取动态路由传值*/</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">绑定数据用：绑定,下面就是将key绑定到router-link上</span><br><span class="line">&lt;router-link :to=&quot;&apos;/content/&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><p>总结：动态路由：第一步：配置动态路由 { path: ‘/content/:id’, component: content }</p><p>第二步：在对应的页面获取动态路由的传值<br>this.$route.params</p><h2 id="get传值"><a href="#get传值" class="headerlink" title="get传值"></a>get传值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get传值就是get请求携带参数</span><br><span class="line">&lt;router-link :to=&quot;&apos;/content?id=&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;</span><br><span class="line">绑定路由的时候</span><br><span class="line">  &#123; path: &apos;/content&apos;, component: Content &#125;就不需要加：id了，</span><br><span class="line">  其实上面的传值是rest风格传值，一般用在android中</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue-动态路由&quot;&gt;&lt;a href=&quot;#vue-动态路由&quot; class=&quot;headerlink&quot; title=&quot;vue 动态路由&quot;&gt;&lt;/a&gt;vue 动态路由&lt;/h1&gt;&lt;h2 id=&quot;传值&quot;&gt;&lt;a href=&quot;#传值&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue路由</title>
    <link href="http://yoursite.com/2019/05/12/vue%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2019/05/12/vue路由/</id>
    <published>2019-05-12T09:38:32.000Z</published>
    <updated>2019-05-12T04:11:05.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue路由"><a href="#vue路由" class="headerlink" title="vue路由"></a>vue路由</h1><p>官网：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vue路由</a></p><p>Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p><p>就是在父组件上可以自由切换子组件<br>配置路由步骤：</p><pre><code>1、创建组件 引入组件2、定义路由  （建议复制s）    const routes = [      { path: &apos;/foo&apos;, component: Foo },      { path: &apos;/bar&apos;, component: Bar },      { path: &apos;*&apos;, redirect: &apos;/home&apos; }   /*默认跳转路由*/    ]3、实例化VueRouter    const router = new VueRouter({      routes // （缩写）相当于 routes: routes    })4、挂载new Vue({  el: &apos;#app&apos;,  router，  render: h =&gt; h(App)})5 、根组件的模板里面放上这句话   &lt;router-view&gt;&lt;/router-view&gt;         6、路由跳转&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue路由&quot;&gt;&lt;a href=&quot;#vue路由&quot; class=&quot;headerlink&quot; title=&quot;vue路由&quot;&gt;&lt;/a&gt;vue路由&lt;/h1&gt;&lt;p&gt;官网：&lt;a href=&quot;https://router.vuejs.org/zh/&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue非父子组件传值</title>
    <link href="http://yoursite.com/2019/05/12/vue%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
    <id>http://yoursite.com/2019/05/12/vue非父子组件传值/</id>
    <published>2019-05-11T17:34:11.000Z</published>
    <updated>2019-05-12T01:50:02.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非父子组件传值"><a href="#非父子组件传值" class="headerlink" title="非父子组件传值"></a>非父子组件传值</h1><p>  1、新建一个js文件   然后引入vue  实例化vue  最后暴露这个实例</p><p>  2、在要广播的地方引入刚才定义的实例</p><p>  3、通过 VueEmit.$emit(‘名称’,’数据’)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&quot;emitnews()&quot;&gt;news组件广播数据&lt;/button&gt;</span><br><span class="line"> methods:&#123;</span><br><span class="line">   emitnews()&#123;</span><br><span class="line">   vueEvent.$emit(&apos;from-news&apos;,this.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  4、在接收收数据的地方通过 $om接收广播的数据<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> mounted()&#123;   <span class="comment">//页面一刷新，就监听</span></span><br><span class="line">VueEmit.$on(<span class="string">'名称'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;非父子组件传值&quot;&gt;&lt;a href=&quot;#非父子组件传值&quot; class=&quot;headerlink&quot; title=&quot;非父子组件传值&quot;&gt;&lt;/a&gt;非父子组件传值&lt;/h1&gt;&lt;p&gt;  1、新建一个js文件   然后引入vue  实例化vue  最后暴露这个实例&lt;/p&gt;
&lt;p&gt;  
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-1</title>
    <link href="http://yoursite.com/2019/05/11/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2019/05/11/vue父子组件通信/</id>
    <published>2019-05-11T10:55:33.000Z</published>
    <updated>2019-05-11T09:28:46.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父子组件交互"><a href="#父子组件交互" class="headerlink" title="父子组件交互"></a>父子组件交互</h1><h2 id="父组件给子组件传值"><a href="#父组件给子组件传值" class="headerlink" title="父组件给子组件传值"></a>父组件给子组件传值</h2><ol><li><p>在父组件中调用子组件中时，绑定动态属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-header</span> <span class="attr">:title</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">v-header</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件中接受传过来的数据有两种表示方式：</p></li></ol><ul><li>通过props直接接收 传过来的属性，如：props:[‘title’]</li><li>接收是可以验证父组件传过来的属性，不符报错，如： props:{‘title’:String }</li></ul><h2 id="父组件主动获取子组件传值"><a href="#父组件主动获取子组件传值" class="headerlink" title="父组件主动获取子组件传值"></a>父组件主动获取子组件传值</h2><ol><li>在父组件中调用子组件中时，定义一个ref<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">v-header</span> <span class="attr">ref</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">v-header</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>在父组件中通过this.$refs.header.子组件属性/方法</li></ol><p>看看vue的官方api说明：</p><blockquote><p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：</p></blockquote><h2 id="子组件主动获取父组件值"><a href="#子组件主动获取父组件值" class="headerlink" title="子组件主动获取父组件值"></a>子组件主动获取父组件值</h2><ul><li>这种是来替代第一种父组件给子组件传值的，通过$parent直接获取父组件的属性和方法。this.$parent.父组件属性/方法<br>看看vue的官方api说明：<blockquote><p>$parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;父子组件交互&quot;&gt;&lt;a href=&quot;#父子组件交互&quot; class=&quot;headerlink&quot; title=&quot;父子组件交互&quot;&gt;&lt;/a&gt;父子组件交互&lt;/h1&gt;&lt;h2 id=&quot;父组件给子组件传值&quot;&gt;&lt;a href=&quot;#父组件给子组件传值&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>angularjs</title>
    <link href="http://yoursite.com/2019/05/10/angularjs/"/>
    <id>http://yoursite.com/2019/05/10/angularjs/</id>
    <published>2019-05-09T20:55:53.000Z</published>
    <updated>2019-05-10T11:18:56.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="angularjs学习："><a href="#angularjs学习：" class="headerlink" title="angularjs学习："></a>angularjs学习：</h1><ul><li>减轻程序员的负担、避免重复劳动</li><li>扩展了Html的功能：颠覆性、可扩展</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>angular是mvc架构。  <ul><li>m 模型—数据</li><li>v 视图—-表现层</li><li>c 控制—业务逻辑</li></ul></li></ol><p>和其他库共存，ng-app=””表示一个范围，归angular。</p><h3 id="双向绑定："><a href="#双向绑定：" class="headerlink" title="双向绑定："></a><strong>双向绑定</strong>：</h3><p>l</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;angularjs学习：&quot;&gt;&lt;a href=&quot;#angularjs学习：&quot; class=&quot;headerlink&quot; title=&quot;angularjs学习：&quot;&gt;&lt;/a&gt;angularjs学习：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;减轻程序员的负担、避免重复劳动&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js—prototype</title>
    <link href="http://yoursite.com/2019/05/10/js%E2%80%94prototype/"/>
    <id>http://yoursite.com/2019/05/10/js—prototype/</id>
    <published>2019-05-09T18:53:42.000Z</published>
    <updated>2019-05-09T10:56:54.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="js原型"><a href="#js原型" class="headerlink" title="js原型"></a>js原型</h1><p>对我以前的研究js原型做一个总结：<br>在刚刚接触JS原型链的时候都会接触到一个熟悉的名词：prototype；如果你曾经深入过prototype，你会接触到另一个名词：<strong>proto</strong>（注意：两边各有两条下划线，不是一条）。以下将会围绕prototype和<strong>proto</strong>这两个名词解释为什么不能在原型链上使用对象以及JS原型链的深层原理。</p><p>　　一、为什么不能在原型链上使用对象：</p><p>　　先举一个非常简单的例子，我有一个类叫Humans（人类），然后我有一个对象叫Tom（一个人）和另一个对象叫Merry(另一个人)，很明显Tom和Merry都是由Humans这一个类实例化之后得到的，然后可以把这个例子写成如下代码：</p><p>复制代码<br>function Humans() {<br>    this.foot = 2;<br>}<br>Humans.prototype.ability = true;</p><p>var Tom = new Humans();<br>var Merry = new Humans();</p><p>alert(Tom.foot);//结果：2<br>alert(Tom.ability);//结果：true<br>alert(Merry.foot);//结果：2<br>alert(Merry.ability);//结果：true<br>复制代码<br>　　以上是一个非常简单的面向对象的例子，相信都能看懂，如果尝试修改Tom的属性ability，则</p><p>复制代码<br>function Humans() {<br>    this.foot = 2;<br>}<br>Humans.prototype.ability = true;</p><p>var Tom = new Humans();<br>var Merry = new Humans();</p><p>Tom.ability = false;<br>alert(Tom.foot);//结果：2<br>alert(Tom.ability);//结果：false<br>alert(Merry.foot);//结果：2<br>alert(Merry.ability);//结果：true<br>复制代码<br>　　以上可以看出Tom的ability属性的值改变了，但并不影响Merry的ability属性的值，这正是我们想要的结果，也是面向对象的好处，由同一个类实例化得到的各个对象之间是互不干扰的；OK，接下来给ability换成object对象又如何?代码如下：</p><p>复制代码<br>function Humans() {<br>    this.foot = 2;<br>}<br>Humans.prototype.ability = {<br>    run : ‘100米/10秒’,<br>    jump : ‘3米’<br>};</p><p>var Tom = new Humans();<br>var Merry = new Humans();</p><p>Tom.ability = {<br>    run : ‘50米/10秒’,<br>    jump : ‘2米’<br>};<br>alert(Tom.ability.run); //结果：’50米/10秒’<br>alert(Tom.ability.jump); //结果：’2米’<br>alert(Merry.ability.run); //结果：’100米/10秒’<br>alert(Merry.ability.jump); //结果：’3米’<br>复制代码<br> 　　以上代码就是在原型链上使用了对象，但从以上代码可以看出Tom的ability属性的改变依然丝毫不会影响Merry的ability的属性，于是乎你会觉得这样的做法并无不妥，为什么说不能在原型链上使用对象?接下来的代码就会显得很不一样，并且可以完全表达出原型链上使用对象的危险性：</p><p>复制代码<br>function Humans() {<br>    this.foot = 2;<br>}<br>Humans.prototype.ability = {<br>    run : ‘100米/10秒’,<br>    jump : ‘3米’<br>};</p><p>var Tom = new Humans();<br>var Merry = new Humans();</p><p>Tom.ability.run = ‘50米/10秒’;<br>Tom.ability.jump = ‘2米’;</p><p>alert(Tom.ability.run); //结果：’50米/10秒’<br>alert(Tom.ability.jump); //结果：’2米’<br>alert(Merry.ability.run); //结果：’50米/10秒’<br>alert(Merry.ability.jump); //结果：’2米’<br>复制代码<br>　　没错，从以上代码的输出结果可以看出Tom的ability属性的改变影响到Merry的ability属性了，于是就可以明白在原型链上使用对象是非常危险的，很容易会打破实例化对象之间的相互独立性，这就是为什么不能在原型链上使用对象的原因?是的，但我想说的可不只如此，而是其中的原理，看完后面JS原型链的深层原理之后，相信你会完全明白。</p><p>　　在以下第二部份解释JS原型链的深层原理之前，先来明确一个概念：原型链上的属性或方法都是被实例化对象共用的，正因如此，上面的Tom.ability.run=’50米/10秒’，改动了原型连上的ability才导致另一个对象Merry受影响，既然如此，你可能会问Tom.ability = {……}不也是改动了原型链上的ability吗，为什么Merry没有受影响?答案是Tom.ability = {……}并没有改动原型链上的ability属性，而是为Tom添加了一个自有属性ability，以后访问Tom.ability的时候不再需要访问原型链上的ability，而是访问其自有属性ability，这是就近原则；OK，如果你仍有疑问，可以用纸笔记下你的疑问，继续往下看你会更加明白。</p><p>　　二、JS原型链的深层原理：</p><p>　　首先要引入一个名词<strong>proto</strong>，<strong>proto</strong>是什么?在我的理解里，<strong>proto</strong>才是真正的原型链，prototype只是一个壳。如果你使用的是chrome浏览器，那么你可以尝试使用alert(Tom.<strong>proto</strong>.ability.run)，你发现这样的写法完全可行，而且事实上当只有原型链上存在ability属性的时候，Tom.ability其实是指向Tom.<strong>proto</strong>.ability的；当然，如果你跑到IE浏览器里尝试必然会报错，事实上IE浏览器禁止了对<strong>proto</strong>的访问，而chrome则是允许的，当然实际开发中，我并不建议直接就使用<strong>proto</strong>这一属性，但它往往在我们调试代码时发挥着重要作用。有人可能会问到底Tom.<strong>proto</strong>和Humans.prototype是什么关系，为了理清两者的关系，下面先列出三条法则：</p><p>　　1、对象是拥有<strong>proto</strong>属性的，但没有prototype；例如：有Tom.<strong>proto</strong>，但没有Tom.prototype。</p><p>　　2、类没有<strong>proto</strong>属性，但有prototype；例如：没有Humans.<strong>proto</strong>，但有Humans.prototype（这里必须纠正一下，同时非常感谢‘川川哥哥’提出这一处错处，确实是我在写到这一点的时候没有考虑清楚，事实上Humans也是Function的一个实例对象，因此Humans.<strong>proto</strong>===Function.prototype是绝对成立的，稍有特殊的是这时Function.prototype是指向一个Empty（空）函数，值得推敲）。</p><p>　　3、由同一个类实例化（new）得到的对象的<strong>proto</strong>是引用该类的prototype的（也就是我们说的引用传递）；例如Tom和Merry的<strong>proto</strong>都引用自Humans的prototype。</p><p> 　　OK，上面说过Tom.ability={……}其实并没有改变原型链上的ability属性，或者说并没有改变Tom.<strong>proto</strong>.ability，而是为Tom添加了一个自有的ability属性，为了说明这一点，我们再次回到以上的第三个代码块，其代码如下：</p><p>复制代码<br>function Humans() {<br>    this.foot = 2;<br>}<br>Humans.prototype.ability = {<br>    run : ‘100米/10秒’,<br>    jump : ‘3米’<br>};</p><p>var Tom = new Humans();<br>var Merry = new Humans();</p><p>Tom.ability = {<br>    run : ‘50米/10秒’,<br>    jump : ‘2米’<br>};<br>alert(Tom.ability.run); //结果：’50米/10秒’<br>alert(Tom.ability.jump); //结果：’2米’<br>alert(Merry.ability.run); //结果：’100米/10秒’<br>alert(Merry.ability.jump); //结果：’3米’<br>复制代码<br>　　当为Tom.ability赋予新的值后，再次访问Tom.ability时就不再指向Tom.<strong>proto</strong>.ability了，因为这时其实是为Tom添加了自有属性ability，可以就近取值了，你可以尝试用Chrome浏览器分别alert(Tom.ability.run)和alert(Tom.<strong>proto</strong>.ability.run)，你会发现确实存在两个不同的值，再看完下面的图后，相信你会完全明白：</p><p>　　于是可以有这样一个结论：当访问一个对象的属性或方法的时候，如果对象本身有这样一个属性或方法就会取其自身的属性或方法，否则会尝试到原型链（<strong>proto</strong>）上寻找同名的属性或方法。明白了这一点后，要解释以上第四个代码块的原理也非常容易了，其代码如下：</p><p>复制代码<br>function Humans() {<br>    this.foot = 2;<br>}<br>Humans.prototype.ability = {<br>    run : ‘100米/10秒’,<br>    jump : ‘3米’<br>};</p><p>var Tom = new Humans();<br>var Merry = new Humans();</p><p>Tom.ability.run = ‘50米/10秒’;<br>Tom.ability.jump = ‘2米’;</p><p>alert(Tom.ability.run); //结果：’50米/10秒’<br>alert(Tom.ability.jump); //结果：’2米’<br>alert(Merry.ability.run); //结果：’50米/10秒’<br>alert(Merry.ability.jump); //结果：’2米’<br>复制代码<br>　　当Tom.ability.run=’50米/10秒’的时候，JS引擎会认为Tom.ability是存在的，因为有Tom.ability才会有Tom.ability.run，所以引擎开始寻找ability属性，首先是会从Tom的自有属性里寻找，在自有属性里并没有找到，于是到原型链里找，结果找到了，于是Tom.ability就指向了Tom.<strong>proto</strong>.ability了，修改Tom.ability.run的时候实际上就是修改了原型链上的ability了，因而影响到了所有由Humans实例化得到的对象，如下图：</p><p>　　希望上面所讲的内容足够清楚明白，下面通过类的继承对原型链作更进一步的深入：</p><p>　　先来看一个类的继承的例子，代码如下：</p><p>复制代码<br>function Person() {<br>    this.hand = 2;<br>    this.foot = 2;<br>}<br>Person.prototype.say = function () {<br>    alert(‘hello’);<br>}<br>function Man() {<br>    Person.apply(this, arguments);//对象冒充<br>    this.head = 1;<br>}<br>Man.prototype = new Person();//原型链<br>Man.prototype.run = function () {<br>    alert(‘I am running’);<br>};<br>Man.prototype.say = function () {<br>    alert(‘good byte’);<br>}<br>var man1 = new Man();<br>复制代码<br> 　　以上代码是使用对象冒充和原型链相结合的混合方法实现类的继承，也是目前JS主流的实现类的继承的方法，如果对这种继承方法缺乏了解，可以看看这里。</p><p>　　接下来看看以上实现继承后的原型链，可以运用prototype和<strong>proto</strong>来解释其中的原理：</p><p>　　1、从man1 = new Man()，可以知道man1的<strong>proto</strong>是指向Man.prototype的，于是有:</p><p>　　公式一：man1.<strong>proto</strong> === Man.prototype 为true</p><p>　　2、从上面的代码原型链继承里面看到这一句代码 Man.prototype = new Person()，作一个转换，变成：Man.prototype = a，a = new Perosn()；一个等式变成了两个等式，于是由a = new Perosn()可以推导出a.<strong>proto</strong> = Person.prototype，结合Man.prototype = a，于是可以得到：</p><p>　　公式二：Man.prototype.<strong>proto</strong> === Person.prototype 为true</p><p>　　由公式一和公式二我们就得出了以下结论：</p><p>　　公式三：man1.<strong>proto</strong>.<strong>proto</strong> === Person.prototype 为true</p><p>　　公式三就是上述代码的原型链，有兴趣的话，可以尝试去推导多重继承的原型链，继承得越多，你会得到一个越长的原型链，而这就是原型链的深层原理；从公式三可以得出一个结论：当你访问一个对象的属性或方法时，会首先在自有属性寻找（man1），如果没有则到原型链找，如果在链上的第一环（第一个<strong>proto</strong>）没找到，则到下一环找（下一个<strong>proto</strong>），直到找到为止，如果到了原型链的尽头仍没找到则返回undefined（这里必须补充一点：同时非常感谢深蓝色梦想提出的疑问：尽头不是到了Object吗?是的，原型链的尽头就是Object，如果想问为什么，不妨做一个小小的实验：如果指定Object.prototype.saySorry = ‘I am sorry’，那么你会惊喜地发现alert(man1.saySorry)是会弹出结果‘I am sorry’的）。</p><p>　　以上就是原型链的深层原理，说难其实也算容易，如果细心研究，会发现原型链上有很多惊喜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;js原型&quot;&gt;&lt;a href=&quot;#js原型&quot; class=&quot;headerlink&quot; title=&quot;js原型&quot;&gt;&lt;/a&gt;js原型&lt;/h1&gt;&lt;p&gt;对我以前的研究js原型做一个总结：&lt;br&gt;在刚刚接触JS原型链的时候都会接触到一个熟悉的名词：prototype；如果你曾经
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue</title>
    <link href="http://yoursite.com/2019/05/09/vue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/05/09/vue父组件传值子组件/</id>
    <published>2019-05-08T20:28:31.000Z</published>
    <updated>2019-05-11T09:29:17.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue的父子传值（包括父组件，值，方法）"><a href="#vue的父子传值（包括父组件，值，方法）" class="headerlink" title="vue的父子传值（包括父组件，值，方法）"></a>vue的父子传值（包括父组件，值，方法）</h1><p>vue的父组件传递给子组件，两步走：<br>在父组件中：<br>1、导入子组件（这是成为父子组件前提）<br>2、components中申明组件<br>3、view中引用<br>4、引用中引入传递的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 所有的内容要被根节点包含起来 --&gt;</span><br><span class="line">    &lt;div id=&quot;home&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;v-header :title=&quot;title&quot; :homemsg=&apos;msg&apos;  :run=&quot;run&quot;  :home=&quot;this&quot;&gt;&lt;/v-header&gt;</span><br><span class="line"></span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">         首页组件   </span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">父组件给子组件传值</span><br><span class="line"></span><br><span class="line">    1.父组件调用子组件的时候 绑定动态属性</span><br><span class="line">        &lt;v-header :title=&quot;title&quot;&gt;&lt;/v-header&gt;</span><br><span class="line"></span><br><span class="line">    2、在子组件里面通过 props接收父组件传过来的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    import Header from &apos;./Header.vue&apos;;</span><br><span class="line"></span><br><span class="line">    export default&#123;</span><br><span class="line">        data()&#123;</span><br><span class="line">            return &#123;               </span><br><span class="line">               msg:&apos;我是一个home组件&apos;,</span><br><span class="line">               title:&apos;首页111&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line"></span><br><span class="line">            &apos;v-header&apos;:Header</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line"></span><br><span class="line">            run(data)&#123;</span><br><span class="line"></span><br><span class="line">                alert(&apos;我是Home组件的run方法&apos;+data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"></span><br><span class="line">    /*css  局部作用域  scoped*/</span><br><span class="line"></span><br><span class="line">    h2&#123;</span><br><span class="line"></span><br><span class="line">        color:red</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>接下来在子组件中使用变量，在props中接收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;h2&gt;我是头部组件--&#123;&#123;title&#125;&#125;---&#123;&#123;homemsg&#125;&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;button @click=&quot;run(&apos;123&apos;)&quot;&gt;执行父组件的方法&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;button @click=&quot;getParent()&quot;&gt;获取父组件的数据和方法&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    </span><br><span class="line">export default&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    data()&#123;</span><br><span class="line"></span><br><span class="line">        return&#123;</span><br><span class="line">            msg:&apos;子组件的msg&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        getParent()&#123;</span><br><span class="line">            // alert(this.title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // alert(this.home.title)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            this.home.run()</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    props:[&apos;title&apos;,&apos;homemsg&apos;,&apos;run&apos;,&apos;home&apos;]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>还可以对父组件传递过来的值验证，不是这种类型就不接受，控制台报错，在子组件接受传递过来的props中设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;</span><br><span class="line">    title:String,</span><br><span class="line">    getParent:Function,</span><br><span class="line">    getHome:Function</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue的父子传值（包括父组件，值，方法）&quot;&gt;&lt;a href=&quot;#vue的父子传值（包括父组件，值，方法）&quot; class=&quot;headerlink&quot; title=&quot;vue的父子传值（包括父组件，值，方法）&quot;&gt;&lt;/a&gt;vue的父子传值（包括父组件，值，方法）&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>github_git</title>
    <link href="http://yoursite.com/2019/05/05/github-git/"/>
    <id>http://yoursite.com/2019/05/05/github-git/</id>
    <published>2019-05-05T12:14:44.000Z</published>
    <updated>2019-05-05T10:51:09.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><hr><p>搭建github就不说了，进入(<strong>仓库主页</strong>)创建仓库，仓库主页在哪?<br>可以在右上角的your repositories，或者在个人主页(your profile)里面有repositories，点一下就是仓库主页。</p><p>在里面创建一个仓库，作为远程仓库。创建完之后，是个空仓库。有个提示，在本地可以用以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git remote add origin https://github.com/pcdegithub/learn.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><p>这样就把本地仓库与远程仓库建立了联系，同时，把本地仓库所有内容推送到远程仓库。 </p><p>如果本地有仓库了，那么就不用再git init初始化一个本地仓库，直接将git remote add origin ssh  远程库的名字就是origin，这是Git默认的叫法。也可以改成别的，但是origin这个名字一看就知道是远程库。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以就可以不用加-u</p><hr><p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆<br>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;搭建github就不说了，进入(&lt;strong&gt;仓库主页&lt;/strong&gt;)创建仓库，仓库主页在哪?&lt;br&gt;可以在
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>learngit</title>
    <link href="http://yoursite.com/2019/05/04/learngit/"/>
    <id>http://yoursite.com/2019/05/04/learngit/</id>
    <published>2019-05-04T15:37:00.000Z</published>
    <updated>2019-05-04T14:32:24.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="温习一下git"><a href="#温习一下git" class="headerlink" title="温习一下git"></a>温习一下git</h1><hr><h2 id="一、基本命令"><a href="#一、基本命令" class="headerlink" title="一、基本命令"></a>一、基本命令</h2><ol><li><p>git init<br>&nbsp;&nbsp;初始化仓库，在本地创建一个仓库，.git记载了版本等信息.</p></li><li><p>git add file<br>&nbsp;&nbsp;file就是要add的文件名，都是同样的做法，将文件放到暂存区（缓存区），然后一次性提交 git add file1; git add file2;git commit -m “一次性提交”</p></li><li><p>git commit -m “description”<br>&nbsp;&nbsp;-m一定要写，方便以后回退查看历史</p></li><li><p>git status  </p></li></ol><hr><p>&nbsp;&nbsp;查看仓库的目前状态。如果仓库来了个新人（创建一个文件），实习期，并没有转正，没交入职材料，没签合同，没录入公司员工管理系统。这时处于未跟踪状态。 </p><ul><li><img src="/2019/05/04/learngit/untracked.png" alt="未追踪" title="untracked"><br>&nbsp;&nbsp;当git add放到缓存中之后，意味通过实习期，开始跟踪了。此时看git status ,准备提交  </li><li><img src="/2019/05/04/learngit/AfterAddtobeCommited.PNG" alt="将提交暂存区" title="to be commited"><br>&nbsp;&nbsp;只要执行一次git add，就是通过实习期,后面 无论什么时候修改文件, git status ,是（not staged for commited）将提交暂存区（起点）</li><li><p><img src="/2019/05/04/learngit/preparedCommit.PNG" alt="将提交暂存区" title="not staged to commit">  </p><h3 id="总结：有两条路："><a href="#总结：有两条路：" class="headerlink" title="总结：有两条路："></a>总结：有两条路：</h3><p>未跟踪和将提交缓存区本质是一个意思，未跟踪也是将要提交缓存区，然后变为跟踪</p><ol><li>untracked–&gt;to be commited  </li><li><p>not staged to commit(将提交暂存区) —&gt;to be commited</p></li><li><p>为什么有两个状态,因为git会 add –commit这一路认为add好后就提交,这只会有一个状态，如果中间有修改了，那么会有另一个状态。下面的图状态发生在git add之后，第一个状态就是默认会提交状态，<br>第二个状态是git add之后又修改了内容（缓存内容变了），所以又回到起点，这时只有先git add重新放回缓存里，<br><img src="/2019/05/04/learngit/why.PNG" alt="将提交暂存区" title="not staged to commit">   </p></li></ol></li></ul><hr><h2 id="其他重要命令"><a href="#其他重要命令" class="headerlink" title="其他重要命令"></a>其他重要命令</h2><ul><li>git diff查看不同 无论是新文件 git add 之后修改，还是老文件git add 之前 之后 。总之在未commted之前，都可以看到当前修改的内容和上个内容。无论提交还是修改都要git add放到缓存区，然后一次性提交。<strong><em>staged:暂存，not staged to commit:还没有提交暂存</em></strong><br><img src="/2019/05/04/learngit/git_diff.PNG" alt="将提交暂存区" title="not staged to commit"></li></ul><hr><ul><li>git reset –HEAD(这里的写法:HEAD^,HEAD^^,HEAD^^^,或者HEAD~100) HEAD^回退到上一个版本，HEAD^^回退到上上个版本……<br>回退之后工作区内容就彻底变了。</li><li>git log查看历史纪录，每个历史纪录在git中叫做commit,相当于快照<br><img src="/2019/05/04/learngit/gitlog.PNG" alt="将提交暂存区" title="not staged to commit">图片中的每条记录名称叫commit，后面是commit的id号，用来回退，之需要输入前几个，git自动识别后面的。Head就是当前版本，指针总是指向head,<br>开始回退：  </li><li>git reset –hard HEAD^ 回退到上一个版本。用git log查看历史纪录，回退之前的版本的记录就没有了。HEAD^这种写法只能回退，不能从过去返回到现在。这时需要commit id了。<br>git reset –hard commitid 只需要写前几位。<br>这个commitid因为查看不到历史纪录，只能用另一个命令</li><li><p>git reflog查看命令历史，以便确定要回到未来的哪个版本。<br>git log可以查看提交历史,只能看到当前版本之前的历史纪录，以便确定要回退到哪个版本。</p><p><strong><em>不管处在什么阶段 ，只要git reset 都直接回退到那个版本，工作区处于无状态即git status查看只会看到nothing to commit, working tree clean</em></strong></p></li></ul><p>无论git log ,git reflog查看历史纪录，每个版本动作操作都记录下了，包括回退。从上到下是最近操作到过去操作<br><img src="/2019/05/04/learngit/reflog_log.PNG" alt="历史纪录" title="log_flog">  </p><hr><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>默认工作区是不包含.git文件夹的，默认的状态，没有修改处于<br>没有对工作区做任何修改，那么工作区就是“干净”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure></p><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。<br>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。<br>需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><h2 id="管理的是修改"><a href="#管理的是修改" class="headerlink" title="管理的是修改"></a>管理的是修改</h2><p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。  </p><p><font face="微软雅黑" color="red"><strong>分析过程</strong></font> ：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit<br>查看最后的状态：Changes not staged for commit (将要提交到缓存） </p><p><font color="green"><strong><em>why?</em></strong></font>:<br>Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。   </p><h3 id="总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。"><a href="#总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。" class="headerlink" title="总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。"></a>总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。</h3><p>##撤销<br>git checkout – 文件 撤销修改，该是什么状态就是什么状态，仅仅撤销工作区的修改，对暂存区没影响。<br>git reset 是回退到历史版本，.git中版本库每次commit都有个版本。不管是暂存区还是什么阶段，都直接回退历史版本，然后状态工作区是历史版本，暂存区为空（干净状态）</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>真正比较的是工作区和版本库中的最新版本，暂存区只是两者的桥梁，仅仅起链接作用。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>直接手动删除，或者rm 文件，这种物理删除，导致工作区和版本库中的最新版本不一致，可以通过git status看到。</p><ul><li>如果想删除版本库中的，那么git rm 文件 ，然后git commit -m “描述”</li><li>如果想撤销物理删除，git checkout – 文件，工作区文件归位。</li><li>如果版本库中该文件版本删除了，那么git checkout就没有用了<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3></li></ul><ol><li><p>对于git add之前，工作区是修改还是删除，都可以“一键还原”， git checkout其实是用版本库里的版本替换工作区的版本。</p></li><li><p>对于添加到暂存区之后，工作区是修改还是删除，也是一键还原到暂存区该有的状态。如：如果添加到暂存区后，又修改了工作区，这时候删除，用git checkout撤销会撤销到暂存区并且未修改状态。</p></li><li>总之该是什么状态就是什么状态</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;温习一下git&quot;&gt;&lt;a href=&quot;#温习一下git&quot; class=&quot;headerlink&quot; title=&quot;温习一下git&quot;&gt;&lt;/a&gt;温习一下git&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、基本命令&quot;&gt;&lt;a href=&quot;#一、基本命令&quot; class=&quot;headerl
      
    
    </summary>
    
    
  </entry>
  
</feed>
