<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo几个命令]]></title>
    <url>%2F2019%2F12%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的ui框架]]></title>
    <url>%2F2019%2F05%2F19%2Fvue%E7%9A%84ui%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[vue的ui框架Element Ui 基于vue 的pc端UI框架 Element Ui MintUi 基于vue移动端的ui框架 MintUi MintUi infinite-scroll结合api接口实现真实下拉分页加载更多 首先解释,webpack打包工具，就是将vue、es6等等解析成了浏览器可以识别的js，html文件。 MintUi是手机端下拉分页加载更多 安装插件npm install mint-ui -S 在main.js中引入12import MintUI from 'mint-ui'Vue.use(Mint); templdate模板中插入infinite-scroll的html,其中loadMore是滚动到列表底部时，触发的方法，loading是开启关闭触发的loadMore方法，默认是false即关闭diabled，所以页面刷新就会默认触发loadMore方法。50是距离页面底部50时触发事件 12345678910111213&lt;template&gt;&lt;div id="add"&gt;&lt;h1 class="page-title"&gt;Infinite Scroll&lt;/h1&gt;&lt;p class="page-infinite-desc"&gt;当即将滚动至列表底部时, 自动加载更多数据&lt;/p&gt; &lt;ul class="page-infinite-list" v-infinite-scroll="loadMore" infinite-scroll-disabled="loading" infinite-scroll-distance="50"&gt; &lt;li v-for="item in list" class="page-infinite-listitem"&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;p id="message"&gt; &lt;!--每页末尾显示--&gt; 加载中...&lt;/p&gt;&lt;/div&gt;&lt;/template&gt; 由于默认刷新时触发方法，所以就不用在周期函数mounted发送异步请求（即不按照官方demo），下面是路由的异步请求，因为是异步，所以要注意： javascript异步实际上是事件队列机制，还是单线程。只有线程空闲时，并且到了指定时间才会执行setTimeout事件。在这空闲时间，如果继续往下拉，继续触发loadMore,这时就会重复执行上次的请求。page=3重复或者page=4重复等等所以需要在进入setTimeout前，要this.loading=true,这样就不会触发loadMore事件，不管用setTimeout还是直接this.$http.jsonp(api).then,都是异步，执行这些js之前限制loading=true,这样在异步事件执行之前都不会触发loadMore,在执行完异步方法后，重新将loading=false，这样下次滚动到地步仍可继续触发loadMore事件，获取数据。如果用setTimeout，来约束滚动到底部多长时间请求数据 123456789101112131415161718192021222324252627282930methods:&#123;requestData()&#123; var api="http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page="+this.page this.$http.jsonp(api).then(function(response)&#123; console.log(response); console.log(this); this.list=response.body.result ++this.page; this.loading=false; if(this.list.length&lt;20)&#123; this.loading=true; &#125;else&#123;this.loading=false;&#125; &#125;, function(err)&#123; console.log(err); &#125;)&#125;,loadMore()&#123;this.loading=true;//必须要，不然会异步重复发送请求setTimeout(()=&gt;&#123;this.requestData();&#125;,2000)&#125; 如果直接this.$http.jsonp(api).then异步请求12345678910111213141516171819202122232425262728293031methods:&#123;requestData()&#123;this.loading=true; //这里必须要，上面已经解释了//api接口catid=20表示每页20条记录，page是当前第几页，page应该是动态的，所以定义了全局变量page拼接 var api="http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page="+this.page this.$http.jsonp(api).then,都是异步，执行这些js之前限制loading=true,这样在异步事件执行之前都不会触发loadMore,在执行完异步方法后，重新将loading=false，这样下次滚动到地步仍可继续触发loadMore事件，获取数据。(function(response)&#123; console.log(response); console.log(this); this.list=this.list.concat(response.body.result); ++this.page; this.loading=false; if(response.body.result.length&lt;20)&#123; this.loading=true; window.document.getElementById("message").style.display="none" &#125;else&#123;this.loading=false;&#125; &#125;, function(err)&#123; console.log(err); &#125;)&#125;,loadMore()&#123;this.requestData();&#125; 当页面分页到最后一页，应该不能继续触发loadMore事件，所以要判断,上面的代码中12345678//response.body.result是当前接口请求数据，上面的api接口//window.document.getElementById("message").style.display="none"是最后一页时要将loading...这几个文字隐藏，隐藏上面的p段落。，//如果没有到最后一页，那么loading=false，滚动到底部继续可触发loadMore事件发送异步请求获取数据//if(response.body.result.length&lt;20)&#123; this.loading=true; window.document.getElementById("message").style.display="none" &#125;else&#123;this.loading=false;&#125; 附：查看接口请求数据F12点击network url 右键，选择 open in new tab或者open in source panel就在source面板打开，都可以一样的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue路由的嵌套]]></title>
    <url>%2F2019%2F05%2F18%2Fvue%E8%B7%AF%E7%94%B1%E7%9A%84%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[路由的嵌套大白话：点击某部分，只有其中部分内容改变，其余部分不变。菜单栏，导航栏啊等等1234567891011121314151617181920import Home from &apos;./components/Home.vue&apos;; import News from &apos;./components/News.vue&apos;; import Content from &apos;./components/content.vue&apos;; import User from &apos;./components/user.vue&apos; import UserAdd from &apos;./components/user/useradd.vue&apos;; import Userlist from &apos;./components/user/userlist.vue&apos;; const routes = [ &#123; path: &apos;/home&apos;, component: Home &#125;, &#123; path: &apos;/news&apos;, component: News &#125;, &#123; path: &apos;/content/:aid&apos;, component: Content &#125;, &#123; path: &apos;/user&apos;, component: User, children:[ &#123;path:&apos;useradd&apos;,component:UserAdd&#125;, &#123;path:&apos;userlist&apos;,component:Userlist&#125; ] &#125;, ]]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue路由编程式导航]]></title>
    <url>%2F2019%2F05%2F16%2Fvue%E8%B7%AF%E7%94%B1%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[vue路由编程式导航就是通过js来跳转到页面在methods中定义一个方法： 1234getContent()&#123; this.$router.push(&#123;path:'/content'&#125;) &#125;// 这就是js代码执行跳转 12 &lt;!--给个按钮--&gt;&lt;button @click="requestData()"&gt;请求数据&lt;/button&gt; 声明式 编程式 router-link :to=”…” replace&gt; router.replace(…) 除了使用 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现即上面那个。 vue路径的hash模式和history模式 在main.js中，创建vue路由实例时 12345const router = new VueRouter(&#123; mode: 'history', /*hash模式改为history ，默认 hash 模式 */ routes // （缩写）相当于 routes: routes &#125;) hash模式路径：http://localhost:8080/#/content/499 带个# history模式路径：http://localhost:8080/content/499 需要后台配置支持]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue动态路由请求数据]]></title>
    <url>%2F2019%2F05%2F14%2Fvue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[vue动态路由请求数据 安装请求数据模块,cnpm install vue-resource –save 在main.js中引入vue-resource插件 在需要的组件的里请求数据，method里定义方法在news.vue中发送请求jsonp请求，1234567891011121314151617181920212223242526272829303132333435363738394041 requestData()&#123; var api=&quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;; this.$http.jsonp(api).then(function(response)&#123; console.log(response); console.log(this); this.list=response.body.result &#125;, function(err)&#123; console.log(err); &#125;) &#125; &#125;, mounted()&#123; this.requestData(); &#125;在mounted中页面刷新时就执行，然后配置路由link&lt;ul&gt; &lt;li v-for=&quot;(item,key) in list&quot;&gt; &lt;router-link :to=&quot;&apos;/content?aid=&apos;+item.aid&quot;&gt;&#123;&#123;item.aid&#125;&#125;--&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt;在content组件中，也在页面刷新时发送个请求，是获取上面路由的动态参数，来执行下面的请求接口的请求携带参数，这就是动态路由mounted()&#123; //console.log(); 获取动态路由传值 var aid=this.$route.query.aid; console.log(&quot;affffffffffffffffffff&quot;,aid) this.requestData(aid); &#125;, methods:&#123; requestData(aid)&#123; var api=&quot;http://www.phonegap100.com/appapi.php?a=getPortalArticle&amp;aid=&quot;+aid this.$http.get(api).then(function(response)&#123; this.list=response.body.result[&quot;0&quot;] console.log(&quot;response----------&quot;,response) &#125;,function(err)&#123; console.log(err); &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue动态路由]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue 动态路由传值每配置router-link跳转，就在main.js中配置一次路由123&lt;router-link :to=&quot;&apos;/content/&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;import content from &apos;./components/content.vue&apos;; 12&#123; path: &apos;/content/:id&apos;, component: content &#125;这就是动态路由，参数不同都能传到同一个路由即/content中，可以获取不同的参数， 12345mounted()&#123;//模板渲染完成之后触发的事件，f5刷新触发的事件 /* console.log(this.$route.params); 获取动态路由传值*/ &#125; 12绑定数据用：绑定,下面就是将key绑定到router-link上&lt;router-link :to=&quot;&apos;/content/&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt; 总结：动态路由：第一步：配置动态路由 { path: ‘/content/:id’, component: content } 第二步：在对应的页面获取动态路由的传值this.$route.params get传值123456get传值就是get请求携带参数&lt;router-link :to=&quot;&apos;/content?id=&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;绑定路由的时候 &#123; path: &apos;/content&apos;, component: Content &#125;就不需要加：id了， 其实上面的传值是rest风格传值，一般用在android中this.$route.query获取携带的参数]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue路由]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue路由官网：vue路由 Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。 就是在父组件上可以自由切换子组件配置路由步骤： 1、创建组件 引入组件 2、定义路由 （建议复制s） const routes = [ { path: &apos;/foo&apos;, component: Foo }, { path: &apos;/bar&apos;, component: Bar }, { path: &apos;*&apos;, redirect: &apos;/home&apos; } /*默认跳转路由*/ ] 3、实例化VueRouter const router = new VueRouter({ routes // （缩写）相当于 routes: routes }) 4、挂载 new Vue({ el: &apos;#app&apos;, router， render: h =&gt; h(App) }) 5 、根组件的模板里面放上这句话 &lt;router-view&gt;&lt;/router-view&gt; 6、路由跳转 &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue非父子组件传值]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[非父子组件传值 1、新建一个js文件 然后引入vue 实例化vue 最后暴露这个实例 2、在要广播的地方引入刚才定义的实例 3、通过 VueEmit.$emit(‘名称’,’数据’) 123456&lt;button @click=&quot;emitnews()&quot;&gt;news组件广播数据&lt;/button&gt; methods:&#123; emitnews()&#123; vueEvent.$emit(&apos;from-news&apos;,this.name); &#125;&#125; 4、在接收收数据的地方通过 $om接收广播的数据 12345 mounted()&#123; //页面一刷新，就监听VueEmit.$on('名称',function()&#123;&#125;) &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-1]]></title>
    <url>%2F2019%2F05%2F11%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父子组件交互父组件给子组件传值 在父组件中调用子组件中时，绑定动态属性 1&lt;v-header :title="title"&gt;&lt;/v-header&gt; 在子组件中接受传过来的数据有两种表示方式： 通过props直接接收 传过来的属性，如：props:[‘title’] 接收是可以验证父组件传过来的属性，不符报错，如： props:{‘title’:String } 父组件主动获取子组件传值 在父组件中调用子组件中时，定义一个ref1&lt;v-header ref="header"&gt;&lt;/v-header&gt; 在父组件中通过this.$refs.header.子组件属性/方法 看看vue的官方api说明： ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 子组件主动获取父组件值 这种是来替代第一种父组件给子组件传值的，通过$parent直接获取父组件的属性和方法。this.$parent.父组件属性/方法看看vue的官方api说明： $parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[angularjs]]></title>
    <url>%2F2019%2F05%2F10%2Fangularjs%2F</url>
    <content type="text"><![CDATA[angularjs学习： 减轻程序员的负担、避免重复劳动 扩展了Html的功能：颠覆性、可扩展 基础 angular是mvc架构。 m 模型—数据 v 视图—-表现层 c 控制—业务逻辑 和其他库共存，ng-app=””表示一个范围，归angular。 双向绑定：l]]></content>
  </entry>
  <entry>
    <title><![CDATA[js—prototype]]></title>
    <url>%2F2019%2F05%2F10%2Fjs%E2%80%94prototype%2F</url>
    <content type="text"><![CDATA[js原型对我以前的研究js原型做一个总结：在刚刚接触JS原型链的时候都会接触到一个熟悉的名词：prototype；如果你曾经深入过prototype，你会接触到另一个名词：proto（注意：两边各有两条下划线，不是一条）。以下将会围绕prototype和proto这两个名词解释为什么不能在原型链上使用对象以及JS原型链的深层原理。 一、为什么不能在原型链上使用对象： 先举一个非常简单的例子，我有一个类叫Humans（人类），然后我有一个对象叫Tom（一个人）和另一个对象叫Merry(另一个人)，很明显Tom和Merry都是由Humans这一个类实例化之后得到的，然后可以把这个例子写成如下代码： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = true; var Tom = new Humans();var Merry = new Humans(); alert(Tom.foot);//结果：2alert(Tom.ability);//结果：truealert(Merry.foot);//结果：2alert(Merry.ability);//结果：true复制代码 以上是一个非常简单的面向对象的例子，相信都能看懂，如果尝试修改Tom的属性ability，则 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = true; var Tom = new Humans();var Merry = new Humans(); Tom.ability = false;alert(Tom.foot);//结果：2alert(Tom.ability);//结果：falsealert(Merry.foot);//结果：2alert(Merry.ability);//结果：true复制代码 以上可以看出Tom的ability属性的值改变了，但并不影响Merry的ability属性的值，这正是我们想要的结果，也是面向对象的好处，由同一个类实例化得到的各个对象之间是互不干扰的；OK，接下来给ability换成object对象又如何?代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability = { run : ‘50米/10秒’, jump : ‘2米’};alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’100米/10秒’alert(Merry.ability.jump); //结果：’3米’复制代码 以上代码就是在原型链上使用了对象，但从以上代码可以看出Tom的ability属性的改变依然丝毫不会影响Merry的ability的属性，于是乎你会觉得这样的做法并无不妥，为什么说不能在原型链上使用对象?接下来的代码就会显得很不一样，并且可以完全表达出原型链上使用对象的危险性： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability.run = ‘50米/10秒’;Tom.ability.jump = ‘2米’; alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’50米/10秒’alert(Merry.ability.jump); //结果：’2米’复制代码 没错，从以上代码的输出结果可以看出Tom的ability属性的改变影响到Merry的ability属性了，于是就可以明白在原型链上使用对象是非常危险的，很容易会打破实例化对象之间的相互独立性，这就是为什么不能在原型链上使用对象的原因?是的，但我想说的可不只如此，而是其中的原理，看完后面JS原型链的深层原理之后，相信你会完全明白。 在以下第二部份解释JS原型链的深层原理之前，先来明确一个概念：原型链上的属性或方法都是被实例化对象共用的，正因如此，上面的Tom.ability.run=’50米/10秒’，改动了原型连上的ability才导致另一个对象Merry受影响，既然如此，你可能会问Tom.ability = {……}不也是改动了原型链上的ability吗，为什么Merry没有受影响?答案是Tom.ability = {……}并没有改动原型链上的ability属性，而是为Tom添加了一个自有属性ability，以后访问Tom.ability的时候不再需要访问原型链上的ability，而是访问其自有属性ability，这是就近原则；OK，如果你仍有疑问，可以用纸笔记下你的疑问，继续往下看你会更加明白。 二、JS原型链的深层原理： 首先要引入一个名词proto，proto是什么?在我的理解里，proto才是真正的原型链，prototype只是一个壳。如果你使用的是chrome浏览器，那么你可以尝试使用alert(Tom.proto.ability.run)，你发现这样的写法完全可行，而且事实上当只有原型链上存在ability属性的时候，Tom.ability其实是指向Tom.proto.ability的；当然，如果你跑到IE浏览器里尝试必然会报错，事实上IE浏览器禁止了对proto的访问，而chrome则是允许的，当然实际开发中，我并不建议直接就使用proto这一属性，但它往往在我们调试代码时发挥着重要作用。有人可能会问到底Tom.proto和Humans.prototype是什么关系，为了理清两者的关系，下面先列出三条法则： 1、对象是拥有proto属性的，但没有prototype；例如：有Tom.proto，但没有Tom.prototype。 2、类没有proto属性，但有prototype；例如：没有Humans.proto，但有Humans.prototype（这里必须纠正一下，同时非常感谢‘川川哥哥’提出这一处错处，确实是我在写到这一点的时候没有考虑清楚，事实上Humans也是Function的一个实例对象，因此Humans.proto===Function.prototype是绝对成立的，稍有特殊的是这时Function.prototype是指向一个Empty（空）函数，值得推敲）。 3、由同一个类实例化（new）得到的对象的proto是引用该类的prototype的（也就是我们说的引用传递）；例如Tom和Merry的proto都引用自Humans的prototype。 OK，上面说过Tom.ability={……}其实并没有改变原型链上的ability属性，或者说并没有改变Tom.proto.ability，而是为Tom添加了一个自有的ability属性，为了说明这一点，我们再次回到以上的第三个代码块，其代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability = { run : ‘50米/10秒’, jump : ‘2米’};alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’100米/10秒’alert(Merry.ability.jump); //结果：’3米’复制代码 当为Tom.ability赋予新的值后，再次访问Tom.ability时就不再指向Tom.proto.ability了，因为这时其实是为Tom添加了自有属性ability，可以就近取值了，你可以尝试用Chrome浏览器分别alert(Tom.ability.run)和alert(Tom.proto.ability.run)，你会发现确实存在两个不同的值，再看完下面的图后，相信你会完全明白： 于是可以有这样一个结论：当访问一个对象的属性或方法的时候，如果对象本身有这样一个属性或方法就会取其自身的属性或方法，否则会尝试到原型链（proto）上寻找同名的属性或方法。明白了这一点后，要解释以上第四个代码块的原理也非常容易了，其代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability.run = ‘50米/10秒’;Tom.ability.jump = ‘2米’; alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’50米/10秒’alert(Merry.ability.jump); //结果：’2米’复制代码 当Tom.ability.run=’50米/10秒’的时候，JS引擎会认为Tom.ability是存在的，因为有Tom.ability才会有Tom.ability.run，所以引擎开始寻找ability属性，首先是会从Tom的自有属性里寻找，在自有属性里并没有找到，于是到原型链里找，结果找到了，于是Tom.ability就指向了Tom.proto.ability了，修改Tom.ability.run的时候实际上就是修改了原型链上的ability了，因而影响到了所有由Humans实例化得到的对象，如下图： 希望上面所讲的内容足够清楚明白，下面通过类的继承对原型链作更进一步的深入： 先来看一个类的继承的例子，代码如下： 复制代码function Person() { this.hand = 2; this.foot = 2;}Person.prototype.say = function () { alert(‘hello’);}function Man() { Person.apply(this, arguments);//对象冒充 this.head = 1;}Man.prototype = new Person();//原型链Man.prototype.run = function () { alert(‘I am running’);};Man.prototype.say = function () { alert(‘good byte’);}var man1 = new Man();复制代码 以上代码是使用对象冒充和原型链相结合的混合方法实现类的继承，也是目前JS主流的实现类的继承的方法，如果对这种继承方法缺乏了解，可以看看这里。 接下来看看以上实现继承后的原型链，可以运用prototype和proto来解释其中的原理： 1、从man1 = new Man()，可以知道man1的proto是指向Man.prototype的，于是有: 公式一：man1.proto === Man.prototype 为true 2、从上面的代码原型链继承里面看到这一句代码 Man.prototype = new Person()，作一个转换，变成：Man.prototype = a，a = new Perosn()；一个等式变成了两个等式，于是由a = new Perosn()可以推导出a.proto = Person.prototype，结合Man.prototype = a，于是可以得到： 公式二：Man.prototype.proto === Person.prototype 为true 由公式一和公式二我们就得出了以下结论： 公式三：man1.proto.proto === Person.prototype 为true 公式三就是上述代码的原型链，有兴趣的话，可以尝试去推导多重继承的原型链，继承得越多，你会得到一个越长的原型链，而这就是原型链的深层原理；从公式三可以得出一个结论：当你访问一个对象的属性或方法时，会首先在自有属性寻找（man1），如果没有则到原型链找，如果在链上的第一环（第一个proto）没找到，则到下一环找（下一个proto），直到找到为止，如果到了原型链的尽头仍没找到则返回undefined（这里必须补充一点：同时非常感谢深蓝色梦想提出的疑问：尽头不是到了Object吗?是的，原型链的尽头就是Object，如果想问为什么，不妨做一个小小的实验：如果指定Object.prototype.saySorry = ‘I am sorry’，那么你会惊喜地发现alert(man1.saySorry)是会弹出结果‘I am sorry’的）。 以上就是原型链的深层原理，说难其实也算容易，如果细心研究，会发现原型链上有很多惊喜。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F05%2F09%2Fvue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E5%AD%90%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue的父子传值（包括父组件，值，方法）vue的父组件传递给子组件，两步走：在父组件中：1、导入子组件（这是成为父子组件前提）2、components中申明组件3、view中引用4、引用中引入传递的变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;!-- 所有的内容要被根节点包含起来 --&gt; &lt;div id=&quot;home&quot;&gt; &lt;v-header :title=&quot;title&quot; :homemsg=&apos;msg&apos; :run=&quot;run&quot; :home=&quot;this&quot;&gt;&lt;/v-header&gt; &lt;hr&gt; 首页组件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/*父组件给子组件传值 1.父组件调用子组件的时候 绑定动态属性 &lt;v-header :title=&quot;title&quot;&gt;&lt;/v-header&gt; 2、在子组件里面通过 props接收父组件传过来的数据*/ import Header from &apos;./Header.vue&apos;; export default&#123; data()&#123; return &#123; msg:&apos;我是一个home组件&apos;, title:&apos;首页111&apos; &#125; &#125;, components:&#123; &apos;v-header&apos;:Header &#125;, methods:&#123; run(data)&#123; alert(&apos;我是Home组件的run方法&apos;+data); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; /*css 局部作用域 scoped*/ h2&#123; color:red &#125; &lt;/style&gt; 接下来在子组件中使用变量，在props中接收123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是头部组件--&#123;&#123;title&#125;&#125;---&#123;&#123;homemsg&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;run(&apos;123&apos;)&quot;&gt;执行父组件的方法&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;button @click=&quot;getParent()&quot;&gt;获取父组件的数据和方法&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; msg:&apos;子组件的msg&apos; &#125; &#125;, methods:&#123; getParent()&#123; // alert(this.title) // alert(this.home.title) this.home.run() &#125; &#125;, props:[&apos;title&apos;,&apos;homemsg&apos;,&apos;run&apos;,&apos;home&apos;] &#125;&lt;/script&gt; 还可以对父组件传递过来的值验证，不是这种类型就不接受，控制台报错，在子组件接受传递过来的props中设置 12345props:&#123; title:String, getParent:Function, getHome:Function &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[github_git]]></title>
    <url>%2F2019%2F05%2F05%2Fgithub-git%2F</url>
    <content type="text"><![CDATA[远程仓库 搭建github就不说了，进入(仓库主页)创建仓库，仓库主页在哪?可以在右上角的your repositories，或者在个人主页(your profile)里面有repositories，点一下就是仓库主页。 在里面创建一个仓库，作为远程仓库。创建完之后，是个空仓库。有个提示，在本地可以用以下命令：12345git initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/pcdegithub/learn.gitgit push -u origin master 这样就把本地仓库与远程仓库建立了联系，同时，把本地仓库所有内容推送到远程仓库。 如果本地有仓库了，那么就不用再git init初始化一个本地仓库，直接将git remote add origin ssh 远程库的名字就是origin，这是Git默认的叫法。也可以改成别的，但是origin这个名字一看就知道是远程库。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以就可以不用加-u 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。]]></content>
  </entry>
  <entry>
    <title><![CDATA[learngit]]></title>
    <url>%2F2019%2F05%2F04%2Flearngit%2F</url>
    <content type="text"><![CDATA[温习一下git 一、基本命令 git init&nbsp;&nbsp;初始化仓库，在本地创建一个仓库，.git记载了版本等信息. git add file&nbsp;&nbsp;file就是要add的文件名，都是同样的做法，将文件放到暂存区（缓存区），然后一次性提交 git add file1; git add file2;git commit -m “一次性提交” git commit -m “description”&nbsp;&nbsp;-m一定要写，方便以后回退查看历史 git status &nbsp;&nbsp;查看仓库的目前状态。如果仓库来了个新人（创建一个文件），实习期，并没有转正，没交入职材料，没签合同，没录入公司员工管理系统。这时处于未跟踪状态。 &nbsp;&nbsp;当git add放到缓存中之后，意味通过实习期，开始跟踪了。此时看git status ,准备提交 &nbsp;&nbsp;只要执行一次git add，就是通过实习期,后面 无论什么时候修改文件, git status ,是（not staged for commited）将提交暂存区（起点） 总结：有两条路：未跟踪和将提交缓存区本质是一个意思，未跟踪也是将要提交缓存区，然后变为跟踪 untracked–&gt;to be commited not staged to commit(将提交暂存区) —&gt;to be commited 为什么有两个状态,因为git会 add –commit这一路认为add好后就提交,这只会有一个状态，如果中间有修改了，那么会有另一个状态。下面的图状态发生在git add之后，第一个状态就是默认会提交状态，第二个状态是git add之后又修改了内容（缓存内容变了），所以又回到起点，这时只有先git add重新放回缓存里， 其他重要命令 git diff查看不同 无论是新文件 git add 之后修改，还是老文件git add 之前 之后 。总之在未commted之前，都可以看到当前修改的内容和上个内容。无论提交还是修改都要git add放到缓存区，然后一次性提交。staged:暂存，not staged to commit:还没有提交暂存 git reset –HEAD(这里的写法:HEAD^,HEAD^^,HEAD^^^,或者HEAD~100) HEAD^回退到上一个版本，HEAD^^回退到上上个版本……回退之后工作区内容就彻底变了。 git log查看历史纪录，每个历史纪录在git中叫做commit,相当于快照图片中的每条记录名称叫commit，后面是commit的id号，用来回退，之需要输入前几个，git自动识别后面的。Head就是当前版本，指针总是指向head,开始回退： git reset –hard HEAD^ 回退到上一个版本。用git log查看历史纪录，回退之前的版本的记录就没有了。HEAD^这种写法只能回退，不能从过去返回到现在。这时需要commit id了。git reset –hard commitid 只需要写前几位。这个commitid因为查看不到历史纪录，只能用另一个命令 git reflog查看命令历史，以便确定要回到未来的哪个版本。git log可以查看提交历史,只能看到当前版本之前的历史纪录，以便确定要回退到哪个版本。 不管处在什么阶段 ，只要git reset 都直接回退到那个版本，工作区处于无状态即git status查看只会看到nothing to commit, working tree clean 无论git log ,git reflog查看历史纪录，每个版本动作操作都记录下了，包括回退。从上到下是最近操作到过去操作 工作区和暂存区默认工作区是不包含.git文件夹的，默认的状态，没有修改处于没有对工作区做任何修改，那么工作区就是“干净”123$ git statusOn branch masternothing to commit, working tree clean 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 管理的是修改什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 分析过程 ：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit查看最后的状态：Changes not staged for commit (将要提交到缓存） why?:Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。##撤销git checkout – 文件 撤销修改，该是什么状态就是什么状态，仅仅撤销工作区的修改，对暂存区没影响。git reset 是回退到历史版本，.git中版本库每次commit都有个版本。不管是暂存区还是什么阶段，都直接回退历史版本，然后状态工作区是历史版本，暂存区为空（干净状态） 总结：真正比较的是工作区和版本库中的最新版本，暂存区只是两者的桥梁，仅仅起链接作用。 删除文件直接手动删除，或者rm 文件，这种物理删除，导致工作区和版本库中的最新版本不一致，可以通过git status看到。 如果想删除版本库中的，那么git rm 文件 ，然后git commit -m “描述” 如果想撤销物理删除，git checkout – 文件，工作区文件归位。 如果版本库中该文件版本删除了，那么git checkout就没有用了总结： 对于git add之前，工作区是修改还是删除，都可以“一键还原”， git checkout其实是用版本库里的版本替换工作区的版本。 对于添加到暂存区之后，工作区是修改还是删除，也是一键还原到暂存区该有的状态。如：如果添加到暂存区后，又修改了工作区，这时候删除，用git checkout撤销会撤销到暂存区并且未修改状态。 总之该是什么状态就是什么状态]]></content>
  </entry>
</search>
