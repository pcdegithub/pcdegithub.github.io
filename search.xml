<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo几个命令]]></title>
    <url>%2F2019%2F12%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F25%2Fbootstrap-0%2F</url>
    <content type="text"><![CDATA[微金所项目实战搭建Bootstrap页面骨架及项目目录结构12345678├─ /weijinsuo/ ··················· 项目所在目录└─┬─ /css/ ······················· 我们自己的CSS文件 ├─ /font/ ······················ 使用到的字体文件 ├─ /img/ ······················· 使用到的图片文件 ├─ /js/ ························ 自己写的JS脚步 ├─ /lib/ ······················· 从第三方下载回来的库【只用不改】 ├─ /favicon.ico ················ 站点图标 └─ /index.html ················· 入口文件 在我们默认的样式表中将默认字体设置为： 123body&#123; font-family: "Helvetica Neue", Helvetica, Microsoft Yahei, Hiragino Sans GB, WenQuanYi Micro Hei, sans-serif;&#125; HTML5文档结构Viewport设置meta:vp 浏览器兼容模式meta:compat favicon.ico完成页面空结构约定编码规范构建顶部通栏container类 用于定义一个固定宽度且居中的版心 字体图标123456789@font-face &#123; font-family: 'itcast'; src: url('../font/MiFie-Web-Font.eot') format('embedded-opentype'), url('../font/MiFie-Web-Font.svg') format('svg'), url('../font/MiFie-Web-Font.ttf') format('truetype'), url('../font/MiFie-Web-Font.woff') format('woff');&#125;[class^="icon-"],[class*=" icon-"] &#123; font-family: itcast;&#125; 格式 eot : embedded-opentype svg : svg ttf : truetype woff : woff 栅格系统row类col-\-*类按钮样式生成 http://blog.koalite.com/bbg/ 小屏幕隐藏导航通栏Bootstrap扩展品牌logo菜单行高调整轮播图Bootstrap JS插件使用background使用background-size length percentage cover contain 图片响应式 目的 实现方式 window resize事件网站特性网格系统媒体对象样式响应式辅助类型- hidden-xx 预约投标pull-leftpull-right投资产品Tab选项卡网格系统::before::aftertooltip插件新闻资讯Tab选项卡响应式偏移合作伙伴相邻兄弟选择器登录对话框模态框表单样式导航吸顶affix组件深度自定义http://v3.bootcss.com/customize通过 Less 文件修改]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F05%2F25%2Fbootstrap-1%2F</url>
    <content type="text"><![CDATA[Bootstrap简介什么是Bootstrap？ 框架：库 lib library jQuery作为一个框架来讲，提供一套比较便捷的操作DOM的方式 把大家都需要的功能预先写好到一些文件 这就是一个框架 Bootstrap 让我们的 Web 开发更简单，更快捷； 注意是 Bootstrap 不是 BootStrap！这是一个词，不是合成词，其含义为：n. 引导指令,引导程序 Bootstrap 是当下最流行的前端框架（界面工具集）； 特点就是灵活简洁，代码优雅，美观大方； 其目的是为了让 Web 开发更敏捷； 是 Twitter 公司的两名前端工程师 Mark Otto 和 Jacob Thornton 在 2011 - 年发起的，并利用业余时间完成第一个版本的开发； 为什么使用Bootstarp？ 生态圈火，不断地更新迭代； 提供一套美观大方地界面组件； 提供一套优雅的 HTML+CSS 编码规范； 让我们的 Web 开发更简单，更快捷； 注意： 使用 Bootstrap 并不代表不用写 CSS 样式，而是不用写绝大多数大家都会用到的样式 准备下载Bootstrap https://github.com/twbs/bootstrap/releases/download/v3.3.6/bootstrap-3.3.6-dist.zip https://github.com/twbs/bootstrap/releases/download/v4.0.0-alpha.2/bootstrap-4.0.0-alpha.2-dist.zip 安装Bootstrap1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;!-- 引入Bootstrap核心样式文件（必须） --&gt; &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt; &lt;!-- 引入Bootstrap默认主题样式（可选） --&gt; &lt;link rel="stylesheet" href="css/bootstrap.theme.min.css"&gt; &lt;!-- 你自己的样式或其他文件 --&gt; &lt;link rel="stylesheet" href="example.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 你的HTML结构...... --&gt; &lt;!-- 以下代码，如果不使用JS插件则不需要 --&gt; &lt;!-- 由于Bootstrap的JS插件依赖jQuery，so 引入jQuery --&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入所有的Bootstrap的JS插件 --&gt; &lt;script src="bootstrap.min.js"&gt;&lt;/script&gt; &lt;!-- 你自己的脚本文件 --&gt; &lt;script src="example.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Bootstrap文档 官方文档 中文文档 基础的Bootstrap模板1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Compatible1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 此属性为文档兼容模式声明，表示如果在IE浏览器下则使用最新的标准渲染当前文档 视口1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 视口的作用：在移动浏览器中，当页面宽度超出设备，浏览器内部虚拟的一个页面容器，将页面容器缩放到设备这么大，然后展示 目前大多数手机浏览器的视口（承载页面的容器）宽度都是980； 视口的宽度可以通过meta标签设置 此属性为移动端页面视口设置，当前值表示在移动端页面的宽度为设备的宽度，并且不缩放（缩放级别为1） width:视口的宽度 initial-scale：初始化缩放 user-scalable:是否允许用户自行缩放（值：yes/no; 1/0） minimum-scale:最小缩放，一般设置了用户不允许缩放，就没必要设置最小和最大缩放 maximum-scale:最大缩放 条件注释 条件注释的作用就是当判断条件满足时，就会执行注释中的HTML代码，不满足时会当做注释忽略掉 第三方依赖 jQuery Bootstrap框架中的所有JS组件都依赖于jQuery实现 html5shiv 让低版本浏览器可以识别HTML5的新标签，如header、footer、section等 respond 让低版本浏览器可以支持CSS媒体查询功能 建议以后在HTML中将脚步的引入放到页面最底下mediaquery12345678910@media (判断条件（针对于当前窗口的判断）)&#123; /*这里的代码只有当判断条件满足时才会执行*/&#125;@media (min-width: 768px) and (max-width: 992px) &#123; /*这里的代码只有当(min-width: 1280px)满足时才会执行*/ .container &#123; width: 750px; &#125;&#125; 当使用min-width作为判断条件一定要从小到大，其原因是CSS从上往下执行 基础CSS样式 概要 + 预置排版样式 统一预制标签样式 按钮样式 + 表格样式 + 表单样式 + 图片样式 + 辅助工具类 + 代码样式 + 栅格系统 xs : 超小屏幕 手机 (&lt;768px) sm : 小屏幕 平板 (≥768px) md : 中等屏幕 桌面显示器 (≥992px) lg : 大屏幕 大桌面显示器 (≥1200px) 响应式工具类 hidden-xx : 在某种屏幕下隐藏 visible-xx : 在某种屏幕尺寸下显示 预置界面组件 导航 导航条 面包屑导航 下拉菜单 按钮式下拉菜单 按钮组 输入框组 警告框 页头 分页 列表组 面板 媒体对象 进度条 Glyphicons 标签 徽章 缩略图 大屏幕 嵌入内容 内嵌 JavaScript插件JavaScript插件的依赖情况如何使用Javascript插件内置组件 模态对话框 下拉菜单 滚动监听 标签页 工具提示 弹出框 警告框 按钮 折叠面板 轮播图 吸顶效果 data-spy=”affix” data-offset-top=”什么位置出现” data-offset-bottom=”什么位置消失” 深度自定义 Bootstrap在线自定义 官网在线 中文网在线 源码编译LESS语言 官方文档 中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端注意]]></title>
    <url>%2F2019%2F05%2F24%2F%E5%89%8D%E7%AB%AF%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[VsCode中使用Emmet神器快速编写HTML代码一、Emmet简述#Emmet (前身为 Zen Coding) 是一个能大幅度提高前端开发效率的一个工具. 在前端开发的过程中，一大部分的工作是写 HTML、CSS 代码。特别是手动编写 HTML 代码的时候，效率会特别低下，因为需要敲打很多尖括号，而且很多标签都需要闭合标签等。于是，就有了 Emmet，它可以极大的提高代码编写的效率，它提供了一种非常简练的语法规则，然后立刻生成对应的 HTML 结构或者 CSS 代码，同时还有多种实用的功能帮助进行前端开发。VsCode内置了Emmet语法,在后缀为.html/.css中输入缩写后按Tab键即会自动生成相应代码 请注意在VsCode新版本中按Tab不再默认启用Emmet展开缩写!需要在首选项配置中将emmet.triggerExpansionOnTab设置为true值! 语法基本规则如下: 12345678CopyE 代表HTML标签。E#id 代表id属性。E.class 代表class属性。E[attr=foo] 代表某一个特定属性。E&#123;foo&#125; 代表标签包含的内容是foo。E&gt;N 代表N是E的子元素。E+N 代表N是E的同级元素。E^N 代表N是E的上级元素。 本文仅介绍了在Html使用Emmet,如果想Css缩写的语法请参考这里https://docs.emmet.io/css-abbreviations/-– 二、基础用法# 元素(Elements)您可以使用元素的名称，如div或p来生成HTML标签。Emmet没有一组可用的标签名称，可以写任何单词并将其转换为标签。也就是只要知道元素的缩写,Emmet会自动转换成对应标签.形如: 1234567891011121314151617181920212223242526Copydiv =&gt; &lt;div&gt; &lt;/div&gt;foo =&gt; &lt;foo&gt; &lt;/foo&gt;html:5 =&gt; 将生成html5标准的包含body为空基本domhtml:xt =&gt; 生成XHTML过渡文档类型,DOCTYPE为XHTMLhtml:4s =&gt; 生成HTML4严格文档类型,DOCTYPE为HTML 4.01a:mail =&gt; &lt;a href=&quot;mailto:&quot;&gt;&lt;/a&gt;a:link =&gt; &lt;a href=&quot;http://&quot;&gt;&lt;/a&gt;base =&gt; &lt;base href=&quot;&quot;&gt;br =&gt; &lt;br&gt;link =&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;script:src =&gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt;form:get =&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&lt;/form&gt;label =&gt; &lt;label for=&quot;&quot;&gt;&lt;/label&gt;input =&gt; &lt;input type=&quot;text&quot;&gt;inp =&gt; &lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;&quot;&gt;input:hidden =&gt; &lt;input type=&quot;hidden&quot; name=&quot;&quot;&gt; input:h亦可input:email =&gt; &lt;input type=&quot;email&quot; name=&quot;&quot; id=&quot;&quot;&gt;input:password =&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;&quot;&gt;input:checkbox =&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot;&gt;input:radio =&gt; &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot;&gt;select =&gt; &lt;select name=&quot;&quot; id=&quot;&quot;&gt;&lt;/select&gt;option =&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt;bq =&gt; &lt;blockquote&gt;&lt;/blockquote&gt;btn =&gt; &lt;button&gt;&lt;/button&gt;btn:s =&gt; &lt;button type=&quot;submit&quot;&gt;&lt;/button&gt;btn:r =&gt; &lt;button type=&quot;reset&quot;&gt;&lt;/button&gt; 文本操作符(Text)如果想在生成元素的同时添加文本内容可以使用{} 1234Copydiv&#123;这是一段文本&#125;&lt;div&gt;这是一段文本&lt;/div&gt;a&#123;点我点我&#125;&lt;a href=&quot;&quot;&gt;点我点我&lt;/a&gt; 属性操作符(Attribute operators) 属性运算符用于修改输出元素的属性. Id和Class (elem#id and elem.class ) 12Copydiv.test =&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;div#pageId =&gt; &lt;div id=&quot;pageId&quot;&gt;&lt;/div&gt; 隐式标签则会自动联想生成对应元素,根据配置规则不同生成的结果也是不同的. 12345678910111213Copy.class=&gt;&lt;div class&gt;&lt;/div&gt;em&gt;.class=&gt;&lt;em&gt;&lt;span class&gt;&lt;/span&gt;&lt;/em&gt;table&gt;.row&gt;.col=&gt;&lt;table&gt; &lt;tr class=&quot;row&quot;&gt; &lt;td class=&quot;col&quot;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 绑定多个类名用.符号连续起来即可 123Copydiv.test1.test2.test3=&gt;&lt;div class=&quot;test1 test2 test3&quot;&gt;&lt;/div&gt; 自定义属性使用 [attr1=’’ attr2=’’] 123Copya[href=&apos;#&apos; data-title=&apos;customer&apos; target=&apos;_blank&apos;]=&gt;&lt;a href=&quot;#&quot; data-title=&quot;customer&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; 嵌套操作符(Nesting operators) 嵌套操作符用于将缩写元素放置在生成的树中,是否应放置在上下文元素的内部或附近. 子级:&gt;通过&gt;标识元素可以生成嵌套子级元素,可以配合元素属性进行连写div#pageId&gt;ul&gt;li =&gt; &lt;div id=&quot;pageId&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 同级:++字符表示生成兄弟级元素.div#pageId+div.child =&gt; &lt;div id=&quot;pageId&quot;&gt;&lt;/div&gt; &lt;div class=&quot;child&quot;&gt;&lt;/div&gt; 父级:^^用于生成父级元素的同级元素,从这个^字符所在位置开始,查找左侧最近的元素的父级元素并生成其兄弟级元素.div&gt;p.parent&gt;span.child^ul.brother&gt;li =&gt; &lt;div&gt; &lt;p class=&quot;parent&quot;&gt;&lt;span class=&quot;child&quot;&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul class=&quot;brother&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 分组操作符(Grouping)分组使用()来实现缩写的分离.比如这个例子,如果不加括号那么a将作为span的子级元素生成.加上括号a将于()内的元素同级. 123456789Copydiv&gt;(ul&gt;li+span)&gt;a=&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;span&gt;&lt;/span&gt; &lt;/ul&gt; &lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/div&gt; 乘法(Multiplication)使用N即可自动生成重复项.N是一个正整数.在使用时请注意N所在位置,位置不同生成的结果不同. 1234567Copyul&gt;li*3=&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 自动计数(numbering)这个功能挺方便的对于生成重复项时增加一个序号,只需要加上$符号即可. 123456Copyul&gt;li.item$&#123;item number:$&#125;*3&lt;ul&gt; &lt;li class=&quot;item1&quot;&gt;item number:1&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;item number:2&lt;/li&gt; &lt;li class=&quot;item3&quot;&gt;item number:3&lt;/li&gt;&lt;/ul&gt; 如果生成两位数则使用两个连续的$$,更多位数以此类推…使用@修饰符，可以更改编号方向（升序或降序）和基数（例如起始值）.注意这个操作符在$之后添加@-表示降序,@+表示升序,默认使用升序.@N可以改变起始值.需要注意的是如果配合升降序使用的话N是放到+-符后. 123456789101112131415Copyul&gt;li.item$@-*3=&gt;&lt;ul&gt; &lt;li class=&quot;item3&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item2&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item1&quot;&gt;&lt;/li&gt;&lt;/ul&gt;---------------------------ul&gt;li.item$@-10*3=&gt;&lt;ul&gt; &lt;li class=&quot;item12&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item11&quot;&gt;&lt;/li&gt; &lt;li class=&quot;item10&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 上述的操作是可以搭配使用进而得出酷炫的效果,使用时请注意空格的问题,缩写代码不要有空格否则是不会进行转换的.另外如果你的编辑器中已经有了一些html智能提示代码段,比如我的VsCode还装了HTML Snippets插件,这个与Emmet语法有部分冲突,使用Tab键时会优先使用插件的代码提示,建议禁用.组合起来看看效果: 1Copytable.table-row[role=&apos;table&apos;]&gt;(thead&gt;tr&gt;td&#123;item $@120&#125;*5)+(tbody&gt;tr&gt;(td.item$$@-)lorem10*5) 这段目的在于生成一个类名为table-row,且自定义了属性role的table标签,内部包含了thead与tbody,分别生成5个td.thead中td的内容是item加上自增序号,自增序号基数从120开始.tbody中td拥有一个名为item加降序自增符号类名,且每个td内容随机填充10个单词. 123456789101112131415161718192021222324252627282930Copy&lt;table class=&quot;table-row&quot; role=&quot;table&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;item 120&lt;/td&gt; &lt;td&gt;item 121&lt;/td&gt; &lt;td&gt;item 122&lt;/td&gt; &lt;td&gt;item 123&lt;/td&gt; &lt;td&gt;item 124&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;td class=&quot;item05&quot;&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Odit, assumenda.&lt;/td&gt; &lt;/td&gt; &lt;td&gt; &lt;td class=&quot;item04&quot;&gt;Magnam possimus molestias ipsum animi rem placeat, ut obcaecati laudantium.&lt;/td&gt; &lt;/td&gt; &lt;td&gt; &lt;td class=&quot;item03&quot;&gt;Consequuntur, labore ad optio cupiditate iusto dolores fugit quidem officiis.&lt;/td&gt; &lt;/td&gt; &lt;td&gt; &lt;td class=&quot;item02&quot;&gt;Veniam, explicabo consequuntur blanditiis at dicta fuga ratione eos beatae.&lt;/td&gt; &lt;/td&gt; &lt;td&gt; &lt;td class=&quot;item01&quot;&gt;Fuga voluptatum illo quis ducimus ad eveniet non. Saepe, eveniet.&lt;/td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 再来个配合嵌套元素和计数的大栗子. 1Copydiv.nav&gt;(nav#navbar&gt;(ul&gt;li&gt;(a[href=&quot;/xxx/product/$&quot; data-index=$]&gt;lorem4)*5))+div.btn[type=&apos;button&apos;]&gt;span&#123;--&#125;^^div#main 这个有点复杂,看下效果: 123456789101112131415Copy&lt;div class=&quot;nav&quot;&gt; &lt;nav id=&quot;navbar&quot;&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=&quot;/xxx/product/1&quot; data-index=&quot;1&quot;&gt;Lorem ipsum dolor sit.&lt;/a&gt; &lt;a href=&quot;/xxx/product/2&quot; data-index=&quot;2&quot;&gt;Dolor vel, quia quas.&lt;/a&gt; &lt;a href=&quot;/xxx/product/3&quot; data-index=&quot;3&quot;&gt;Qui hic, corrupti eum!&lt;/a&gt; &lt;a href=&quot;/xxx/product/4&quot; data-index=&quot;4&quot;&gt;Necessitatibus perspiciatis, corrupti. Praesentium!&lt;/a&gt; &lt;a href=&quot;/xxx/product/5&quot; data-index=&quot;5&quot;&gt;Nostrum quos, voluptate. Velit!&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;span&gt;--&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;main&quot;&gt;&lt;/div&gt; 三、进阶高级用法# 模拟文本/随机文本在开发时经常要填充一些文本内容占位,Emmet内置了Lorem Ipsum功能来实现.loremN或者lipsumN,N表示生成的单词数,正整数.可以不填. 123456789101112Copylorem=&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Suscipit quia commodi vero sint omnis fugiat excepturi reiciendis necessitatibus totam asperiores, delectus saepe nulla consequuntur nostrum! Saepe suscipit recusandae repellendus assumenda.p&gt;lorem4=&gt;&lt;p&gt;Lorem ipsum dolor sit.&lt;/p&gt;(p&gt;lorem4)*3=&gt;&lt;p&gt;Lorem ipsum dolor sit.&lt;/p&gt;&lt;p&gt;Labore aperiam, consequuntur architecto.&lt;/p&gt;&lt;p&gt;Quidem nisi, cum odio!&lt;/p&gt; 包装文本听起来可能有点绕,通俗点解释就是把一段指定的文本包装成我们想要的结构.注意这个功能需要编辑器的支持,举个大栗子:比如PM给了这样一段文本 123456789101112131415Copy首页产品介绍相关案例关于我们联系我们而我们预期的效果是这样&lt;nav&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品介绍&lt;/li&gt; &lt;li&gt;相关案例&lt;/li&gt; &lt;li&gt;关于我们&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 选中文本,按下ctrl+shift+p打开命令窗口输入ewrap 选择Emmet:使用缩写进行包装(Wrap with Abbreviation)选项 输入缩写字符nav&gt;ul&gt;li*按下回车键即可看到效果.当然也可以在菜单=&gt;编辑=&gt;Emmet(M)..然后输入. 这里需要的注意的地方是输入的缩写代码中*所在位置不同得到的效果也是不同的. 另外如果给的文本带有序号的情况,我们也是可以通过缩写来处理,而不是手动删除,主要用的是|t来处理.比如: 12345678Copy 1.首页 2.产品介绍 3.相关案例 4.关于我们 5.联系我们 输入包装字符命令 nav&gt;ul&gt;li*|t 即可看到生成的html中自动去掉了序号 针对上边说的几种情况来演示一下.利用好Emmet来快速编写html代码,能提升工作效率不用在一个个敲闭合标签,简直是我等偷懒党神器.赶快去耍耍吧.]]></content>
  </entry>
  <entry>
    <title><![CDATA[前端几个构建工具]]></title>
    <url>%2F2019%2F05%2F20%2F%E5%89%8D%E7%AB%AF%E5%87%A0%E4%B8%AA%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.npm 就不扯了，天天用,npm 下载的依赖安装位置： 若是全局npm install -g 则放在C:\Users\fang\AppData\Roaming\npm\node_modules 是默认位置 若是在命令行输入npm install 没有-g,就是在当前目录npm init 会在当前目录下初始化package.json来管理npm信息 2.bower包管理工具，和npm一样。web应用程序依赖管理。安装：npm install -g bower,命令和npm差不多 bower init 清单文件定义bower.json。这类似于Node package.json或Ruby Gemfile。 一般来说bower install jQuery –save-dev ，这个操作可以往bower.json里面写入对应的模块，它可以实现不同之间的重复安装。其他项目成员，拿到项目之后，只需要bower install 就好了。bower install是可以直接从bower.json里面读出来的，其他项目成员就不需要写bower install jQuery了。 现在npm最常用于Node.Js模块，Npm是嵌套依赖树的关系，你应该知道删除npm模块，你不用rimraf node_modules模块，都不行，嵌套依赖就是，你依赖我，我依赖它，再依赖它。NPM嵌套依赖用在服务器上十分好，不用关心版本冲突问题等等。 Bower是专门为前端创建的，它对于依赖的管理是属于扁平化的。 现在一般项目里面，既有Bower和Node，因为前端还需要一些Gulp，Webpack这样的构建工具。 3.gulp3.1.gulp简介 链接： 官网 中文网-就是用来机械化的完成重复性质的工作 gulp的机制就是将重复的工作抽象成一个个任务 3.2.gulp准备工作 安装Node.js 安装 gulp 命令行工具 npm install -g gulp 初始化 gulp 项目 创建任务 - gulpfile.js 4.webpack]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue的ui框架]]></title>
    <url>%2F2019%2F05%2F19%2Fvue%E7%9A%84ui%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[vue的ui框架Element Ui 基于vue 的pc端UI框架 Element Ui MintUi 基于vue移动端的ui框架 MintUi 如果api上面的例子无法执行，就看demo,直接引入到组件 import infiniteScroll from ‘../infinite-scroll.vue’; 123&apos;V-infiniteScroll&apos;:infiniteScroll&#125;, view中\\就可以了 MintUi infinite-scroll结合api接口实现真实下拉分页加载更多 首先解释,webpack打包工具，就是将vue、es6等等解析成了浏览器可以识别的js，html文件。 MintUi是手机端下拉分页加载更多 安装插件 npm install mint-ui -S 在main.js中引入12import MintUI from 'mint-ui'Vue.use(Mint); templdate模板中插入infinite-scroll的html,其中loadMore是滚动到列表底部时，触发的方法，loading是开启关闭触发的loadMore方法，默认是false即关闭diabled，所以页面刷新就会默认触发loadMore方法。50是距离页面底部50时触发事件 12345678910111213&lt;template&gt;&lt;div id="add"&gt;&lt;h1 class="page-title"&gt;Infinite Scroll&lt;/h1&gt;&lt;p class="page-infinite-desc"&gt;当即将滚动至列表底部时, 自动加载更多数据&lt;/p&gt; &lt;ul class="page-infinite-list" v-infinite-scroll="loadMore" infinite-scroll-disabled="loading" infinite-scroll-distance="50"&gt; &lt;li v-for="item in list" class="page-infinite-listitem"&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;p id="message"&gt; &lt;!--每页末尾显示--&gt; 加载中...&lt;/p&gt;&lt;/div&gt;&lt;/template&gt; 由于默认刷新时触发方法，所以就不用在周期函数mounted发送异步请求（即不按照官方demo），下面是路由的异步请求，因为是异步，所以要注意： javascript异步实际上是事件队列机制，还是单线程。只有线程空闲时，并且到了指定时间才会执行setTimeout事件。在这空闲时间，如果继续往下拉，继续触发loadMore,这时就会重复执行上次的请求。page=3重复或者page=4重复等等所以需要在进入setTimeout前，要this.loading=true,这样就不会触发loadMore事件，不管用setTimeout还是直接this.$http.jsonp(api).then,都是异步，执行这些js之前限制loading=true,这样在异步事件执行之前都不会触发loadMore,在执行完异步方法后，重新将loading=false，这样下次滚动到地步仍可继续触发loadMore事件，获取数据。如果用setTimeout，来约束滚动到底部多长时间请求数据 123456789101112131415161718192021222324252627282930methods:&#123;requestData()&#123; var api="http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page="+this.page this.$http.jsonp(api).then(function(response)&#123; console.log(response); console.log(this); this.list=response.body.result ++this.page; this.loading=false; if(this.list.length&lt;20)&#123; this.loading=true; &#125;else&#123;this.loading=false;&#125; &#125;, function(err)&#123; console.log(err); &#125;)&#125;,loadMore()&#123;this.loading=true;//必须要，不然会异步重复发送请求setTimeout(()=&gt;&#123;this.requestData();&#125;,2000)&#125; 如果直接this.$http.jsonp(api).then异步请求12345678910111213141516171819202122232425262728293031methods:&#123;requestData()&#123;this.loading=true; //这里必须要，上面已经解释了//api接口catid=20表示每页20条记录，page是当前第几页，page应该是动态的，所以定义了全局变量page拼接 var api="http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page="+this.page this.$http.jsonp(api).then,都是异步，执行这些js之前限制loading=true,这样在异步事件执行之前都不会触发loadMore,在执行完异步方法后，重新将loading=false，这样下次滚动到地步仍可继续触发loadMore事件，获取数据。(function(response)&#123; console.log(response); console.log(this); this.list=this.list.concat(response.body.result); ++this.page; this.loading=false; if(response.body.result.length&lt;20)&#123; this.loading=true; window.document.getElementById("message").style.display="none" &#125;else&#123;this.loading=false;&#125; &#125;, function(err)&#123; console.log(err); &#125;)&#125;,loadMore()&#123;this.requestData();&#125; 当页面分页到最后一页，应该不能继续触发loadMore事件，所以要判断,上面的代码中12345678//response.body.result是当前接口请求数据，上面的api接口//window.document.getElementById("message").style.display="none"是最后一页时要将loading...这几个文字隐藏，隐藏上面的p段落。，//如果没有到最后一页，那么loading=false，滚动到底部继续可触发loadMore事件发送异步请求获取数据//if(response.body.result.length&lt;20)&#123; this.loading=true; window.document.getElementById("message").style.display="none" &#125;else&#123;this.loading=false;&#125; 附：查看接口请求数据F12点击network url 右键，选择 open in new tab或者open in source panel就在source面板打开，都可以一样的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue路由的嵌套]]></title>
    <url>%2F2019%2F05%2F18%2Fvue%E8%B7%AF%E7%94%B1%E7%9A%84%E5%B5%8C%E5%A5%97%2F</url>
    <content type="text"><![CDATA[路由的嵌套大白话：点击某部分，只有其中部分内容改变，其余部分不变。菜单栏，导航栏啊等等1234567891011121314151617181920import Home from &apos;./components/Home.vue&apos;; import News from &apos;./components/News.vue&apos;; import Content from &apos;./components/content.vue&apos;; import User from &apos;./components/user.vue&apos; import UserAdd from &apos;./components/user/useradd.vue&apos;; import Userlist from &apos;./components/user/userlist.vue&apos;; const routes = [ &#123; path: &apos;/home&apos;, component: Home &#125;, &#123; path: &apos;/news&apos;, component: News &#125;, &#123; path: &apos;/content/:aid&apos;, component: Content &#125;, &#123; path: &apos;/user&apos;, component: User, children:[ &#123;path:&apos;useradd&apos;,component:UserAdd&#125;, &#123;path:&apos;userlist&apos;,component:Userlist&#125; ] &#125;, ]]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue路由编程式导航]]></title>
    <url>%2F2019%2F05%2F16%2Fvue%E8%B7%AF%E7%94%B1%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%2F</url>
    <content type="text"><![CDATA[vue路由编程式导航就是通过js来跳转到页面在methods中定义一个方法： 1234getContent()&#123; this.$router.push(&#123;path:'/content'&#125;) &#125;// 这就是js代码执行跳转 12 &lt;!--给个按钮--&gt;&lt;button @click="requestData()"&gt;请求数据&lt;/button&gt; 声明式 编程式 router-link :to=”…” replace&gt; router.replace(…) 除了使用 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现即上面那个。 vue路径的hash模式和history模式 在main.js中，创建vue路由实例时 12345const router = new VueRouter(&#123; mode: 'history', /*hash模式改为history ，默认 hash 模式 */ routes // （缩写）相当于 routes: routes &#125;) hash模式路径：http://localhost:8080/#/content/499 带个# history模式路径：http://localhost:8080/content/499 需要后台配置支持]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue动态路由请求数据]]></title>
    <url>%2F2019%2F05%2F14%2Fvue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[vue动态路由请求数据 安装请求数据模块,cnpm install vue-resource –save 在main.js中引入vue-resource插件 在需要的组件的里请求数据，method里定义方法在news.vue中发送请求jsonp请求，1234567891011121314151617181920212223242526272829303132333435363738394041 requestData()&#123; var api=&quot;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1&quot;; this.$http.jsonp(api).then(function(response)&#123; console.log(response); console.log(this); this.list=response.body.result &#125;, function(err)&#123; console.log(err); &#125;) &#125; &#125;, mounted()&#123; this.requestData(); &#125;在mounted中页面刷新时就执行，然后配置路由link&lt;ul&gt; &lt;li v-for=&quot;(item,key) in list&quot;&gt; &lt;router-link :to=&quot;&apos;/content?aid=&apos;+item.aid&quot;&gt;&#123;&#123;item.aid&#125;&#125;--&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;&lt;/li&gt;在content组件中，也在页面刷新时发送个请求，是获取上面路由的动态参数，来执行下面的请求接口的请求携带参数，这就是动态路由mounted()&#123; //console.log(); 获取动态路由传值 var aid=this.$route.query.aid; console.log(&quot;affffffffffffffffffff&quot;,aid) this.requestData(aid); &#125;, methods:&#123; requestData(aid)&#123; var api=&quot;http://www.phonegap100.com/appapi.php?a=getPortalArticle&amp;aid=&quot;+aid this.$http.get(api).then(function(response)&#123; this.list=response.body.result[&quot;0&quot;] console.log(&quot;response----------&quot;,response) &#125;,function(err)&#123; console.log(err); &#125;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue动态路由]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue 动态路由传值每配置router-link跳转，就在main.js中配置一次路由123&lt;router-link :to=&quot;&apos;/content/&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;import content from &apos;./components/content.vue&apos;; 12&#123; path: &apos;/content/:id&apos;, component: content &#125;这就是动态路由，参数不同都能传到同一个路由即/content中，可以获取不同的参数， 12345mounted()&#123;//模板渲染完成之后触发的事件，f5刷新触发的事件 /* console.log(this.$route.params); 获取动态路由传值*/ &#125; 12绑定数据用：绑定,下面就是将key绑定到router-link上&lt;router-link :to=&quot;&apos;/content/&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt; 总结：动态路由：第一步：配置动态路由 { path: ‘/content/:id’, component: content } 第二步：在对应的页面获取动态路由的传值this.$route.params get传值123456get传值就是get请求携带参数&lt;router-link :to=&quot;&apos;/content?id=&apos;+key&quot;&gt;&#123;&#123;key&#125;&#125;--&#123;&#123;item&#125;&#125;&lt;/router-link&gt;绑定路由的时候 &#123; path: &apos;/content&apos;, component: Content &#125;就不需要加：id了， 其实上面的传值是rest风格传值，一般用在android中this.$route.query获取携带的参数]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue路由]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[vue路由官网：vue路由 Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。 就是在父组件上可以自由切换子组件配置路由步骤： 1、创建组件 引入组件 2、定义路由 （建议复制s） const routes = [ { path: &apos;/foo&apos;, component: Foo }, { path: &apos;/bar&apos;, component: Bar }, { path: &apos;*&apos;, redirect: &apos;/home&apos; } /*默认跳转路由*/ ] 3、实例化VueRouter const router = new VueRouter({ routes // （缩写）相当于 routes: routes }) 4、挂载 new Vue({ el: &apos;#app&apos;, router， render: h =&gt; h(App) }) 5 、根组件的模板里面放上这句话 &lt;router-view&gt;&lt;/router-view&gt; 6、路由跳转 &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue非父子组件传值]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[非父子组件传值 1、新建一个js文件 然后引入vue 实例化vue 最后暴露这个实例 2、在要广播的地方引入刚才定义的实例 3、通过 VueEmit.$emit(‘名称’,’数据’) 123456&lt;button @click=&quot;emitnews()&quot;&gt;news组件广播数据&lt;/button&gt; methods:&#123; emitnews()&#123; vueEvent.$emit(&apos;from-news&apos;,this.name); &#125;&#125; 4、在接收收数据的地方通过 $om接收广播的数据 12345 mounted()&#123; //页面一刷新，就监听VueEmit.$on('名称',function()&#123;&#125;) &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-1]]></title>
    <url>%2F2019%2F05%2F11%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父子组件交互父组件给子组件传值 在父组件中调用子组件中时，绑定动态属性 1&lt;v-header :title="title"&gt;&lt;/v-header&gt; 在子组件中接受传过来的数据有两种表示方式： 通过props直接接收 传过来的属性，如：props:[‘title’] 接收是可以验证父组件传过来的属性，不符报错，如： props:{‘title’:String } 父组件主动获取子组件传值 在父组件中调用子组件中时，定义一个ref1&lt;v-header ref="header"&gt;&lt;/v-header&gt; 在父组件中通过this.$refs.header.子组件属性/方法 看看vue的官方api说明： ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 子组件主动获取父组件值 这种是来替代第一种父组件给子组件传值的，通过$parent直接获取父组件的属性和方法。this.$parent.父组件属性/方法看看vue的官方api说明： $parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[angularjs]]></title>
    <url>%2F2019%2F05%2F10%2Fangularjs%2F</url>
    <content type="text"><![CDATA[angularjs学习： 减轻程序员的负担、避免重复劳动 扩展了Html的功能：颠覆性、可扩展 基础 angular是mvc架构。 m 模型—数据 v 视图—-表现层 c 控制—业务逻辑 和其他库共存，ng-app=””表示一个范围，归angular。 双向绑定：l]]></content>
  </entry>
  <entry>
    <title><![CDATA[js—prototype]]></title>
    <url>%2F2019%2F05%2F10%2Fjs%E2%80%94prototype%2F</url>
    <content type="text"><![CDATA[js原型对我以前的研究js原型做一个总结：在刚刚接触JS原型链的时候都会接触到一个熟悉的名词：prototype；如果你曾经深入过prototype，你会接触到另一个名词：proto（注意：两边各有两条下划线，不是一条）。以下将会围绕prototype和proto这两个名词解释为什么不能在原型链上使用对象以及JS原型链的深层原理。 一、为什么不能在原型链上使用对象： 先举一个非常简单的例子，我有一个类叫Humans（人类），然后我有一个对象叫Tom（一个人）和另一个对象叫Merry(另一个人)，很明显Tom和Merry都是由Humans这一个类实例化之后得到的，然后可以把这个例子写成如下代码： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = true; var Tom = new Humans();var Merry = new Humans(); alert(Tom.foot);//结果：2alert(Tom.ability);//结果：truealert(Merry.foot);//结果：2alert(Merry.ability);//结果：true复制代码 以上是一个非常简单的面向对象的例子，相信都能看懂，如果尝试修改Tom的属性ability，则 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = true; var Tom = new Humans();var Merry = new Humans(); Tom.ability = false;alert(Tom.foot);//结果：2alert(Tom.ability);//结果：falsealert(Merry.foot);//结果：2alert(Merry.ability);//结果：true复制代码 以上可以看出Tom的ability属性的值改变了，但并不影响Merry的ability属性的值，这正是我们想要的结果，也是面向对象的好处，由同一个类实例化得到的各个对象之间是互不干扰的；OK，接下来给ability换成object对象又如何?代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability = { run : ‘50米/10秒’, jump : ‘2米’};alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’100米/10秒’alert(Merry.ability.jump); //结果：’3米’复制代码 以上代码就是在原型链上使用了对象，但从以上代码可以看出Tom的ability属性的改变依然丝毫不会影响Merry的ability的属性，于是乎你会觉得这样的做法并无不妥，为什么说不能在原型链上使用对象?接下来的代码就会显得很不一样，并且可以完全表达出原型链上使用对象的危险性： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability.run = ‘50米/10秒’;Tom.ability.jump = ‘2米’; alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’50米/10秒’alert(Merry.ability.jump); //结果：’2米’复制代码 没错，从以上代码的输出结果可以看出Tom的ability属性的改变影响到Merry的ability属性了，于是就可以明白在原型链上使用对象是非常危险的，很容易会打破实例化对象之间的相互独立性，这就是为什么不能在原型链上使用对象的原因?是的，但我想说的可不只如此，而是其中的原理，看完后面JS原型链的深层原理之后，相信你会完全明白。 在以下第二部份解释JS原型链的深层原理之前，先来明确一个概念：原型链上的属性或方法都是被实例化对象共用的，正因如此，上面的Tom.ability.run=’50米/10秒’，改动了原型连上的ability才导致另一个对象Merry受影响，既然如此，你可能会问Tom.ability = {……}不也是改动了原型链上的ability吗，为什么Merry没有受影响?答案是Tom.ability = {……}并没有改动原型链上的ability属性，而是为Tom添加了一个自有属性ability，以后访问Tom.ability的时候不再需要访问原型链上的ability，而是访问其自有属性ability，这是就近原则；OK，如果你仍有疑问，可以用纸笔记下你的疑问，继续往下看你会更加明白。 二、JS原型链的深层原理： 首先要引入一个名词proto，proto是什么?在我的理解里，proto才是真正的原型链，prototype只是一个壳。如果你使用的是chrome浏览器，那么你可以尝试使用alert(Tom.proto.ability.run)，你发现这样的写法完全可行，而且事实上当只有原型链上存在ability属性的时候，Tom.ability其实是指向Tom.proto.ability的；当然，如果你跑到IE浏览器里尝试必然会报错，事实上IE浏览器禁止了对proto的访问，而chrome则是允许的，当然实际开发中，我并不建议直接就使用proto这一属性，但它往往在我们调试代码时发挥着重要作用。有人可能会问到底Tom.proto和Humans.prototype是什么关系，为了理清两者的关系，下面先列出三条法则： 1、对象是拥有proto属性的，但没有prototype；例如：有Tom.proto，但没有Tom.prototype。 2、类没有proto属性，但有prototype；例如：没有Humans.proto，但有Humans.prototype（这里必须纠正一下，同时非常感谢‘川川哥哥’提出这一处错处，确实是我在写到这一点的时候没有考虑清楚，事实上Humans也是Function的一个实例对象，因此Humans.proto===Function.prototype是绝对成立的，稍有特殊的是这时Function.prototype是指向一个Empty（空）函数，值得推敲）。 3、由同一个类实例化（new）得到的对象的proto是引用该类的prototype的（也就是我们说的引用传递）；例如Tom和Merry的proto都引用自Humans的prototype。 OK，上面说过Tom.ability={……}其实并没有改变原型链上的ability属性，或者说并没有改变Tom.proto.ability，而是为Tom添加了一个自有的ability属性，为了说明这一点，我们再次回到以上的第三个代码块，其代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability = { run : ‘50米/10秒’, jump : ‘2米’};alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’100米/10秒’alert(Merry.ability.jump); //结果：’3米’复制代码 当为Tom.ability赋予新的值后，再次访问Tom.ability时就不再指向Tom.proto.ability了，因为这时其实是为Tom添加了自有属性ability，可以就近取值了，你可以尝试用Chrome浏览器分别alert(Tom.ability.run)和alert(Tom.proto.ability.run)，你会发现确实存在两个不同的值，再看完下面的图后，相信你会完全明白： 于是可以有这样一个结论：当访问一个对象的属性或方法的时候，如果对象本身有这样一个属性或方法就会取其自身的属性或方法，否则会尝试到原型链（proto）上寻找同名的属性或方法。明白了这一点后，要解释以上第四个代码块的原理也非常容易了，其代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability.run = ‘50米/10秒’;Tom.ability.jump = ‘2米’; alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’50米/10秒’alert(Merry.ability.jump); //结果：’2米’复制代码 当Tom.ability.run=’50米/10秒’的时候，JS引擎会认为Tom.ability是存在的，因为有Tom.ability才会有Tom.ability.run，所以引擎开始寻找ability属性，首先是会从Tom的自有属性里寻找，在自有属性里并没有找到，于是到原型链里找，结果找到了，于是Tom.ability就指向了Tom.proto.ability了，修改Tom.ability.run的时候实际上就是修改了原型链上的ability了，因而影响到了所有由Humans实例化得到的对象，如下图： 希望上面所讲的内容足够清楚明白，下面通过类的继承对原型链作更进一步的深入： 先来看一个类的继承的例子，代码如下： 复制代码function Person() { this.hand = 2; this.foot = 2;}Person.prototype.say = function () { alert(‘hello’);}function Man() { Person.apply(this, arguments);//对象冒充 this.head = 1;}Man.prototype = new Person();//原型链Man.prototype.run = function () { alert(‘I am running’);};Man.prototype.say = function () { alert(‘good byte’);}var man1 = new Man();复制代码 以上代码是使用对象冒充和原型链相结合的混合方法实现类的继承，也是目前JS主流的实现类的继承的方法，如果对这种继承方法缺乏了解，可以看看这里。 接下来看看以上实现继承后的原型链，可以运用prototype和proto来解释其中的原理： 1、从man1 = new Man()，可以知道man1的proto是指向Man.prototype的，于是有: 公式一：man1.proto === Man.prototype 为true 2、从上面的代码原型链继承里面看到这一句代码 Man.prototype = new Person()，作一个转换，变成：Man.prototype = a，a = new Perosn()；一个等式变成了两个等式，于是由a = new Perosn()可以推导出a.proto = Person.prototype，结合Man.prototype = a，于是可以得到： 公式二：Man.prototype.proto === Person.prototype 为true 由公式一和公式二我们就得出了以下结论： 公式三：man1.proto.proto === Person.prototype 为true 公式三就是上述代码的原型链，有兴趣的话，可以尝试去推导多重继承的原型链，继承得越多，你会得到一个越长的原型链，而这就是原型链的深层原理；从公式三可以得出一个结论：当你访问一个对象的属性或方法时，会首先在自有属性寻找（man1），如果没有则到原型链找，如果在链上的第一环（第一个proto）没找到，则到下一环找（下一个proto），直到找到为止，如果到了原型链的尽头仍没找到则返回undefined（这里必须补充一点：同时非常感谢深蓝色梦想提出的疑问：尽头不是到了Object吗?是的，原型链的尽头就是Object，如果想问为什么，不妨做一个小小的实验：如果指定Object.prototype.saySorry = ‘I am sorry’，那么你会惊喜地发现alert(man1.saySorry)是会弹出结果‘I am sorry’的）。 以上就是原型链的深层原理，说难其实也算容易，如果细心研究，会发现原型链上有很多惊喜。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F05%2F09%2Fvue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E5%AD%90%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue的父子传值（包括父组件，值，方法）vue的父组件传递给子组件，两步走：在父组件中：1、导入子组件（这是成为父子组件前提）2、components中申明组件3、view中引用4、引用中引入传递的变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;!-- 所有的内容要被根节点包含起来 --&gt; &lt;div id=&quot;home&quot;&gt; &lt;v-header :title=&quot;title&quot; :homemsg=&apos;msg&apos; :run=&quot;run&quot; :home=&quot;this&quot;&gt;&lt;/v-header&gt; &lt;hr&gt; 首页组件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/*父组件给子组件传值 1.父组件调用子组件的时候 绑定动态属性 &lt;v-header :title=&quot;title&quot;&gt;&lt;/v-header&gt; 2、在子组件里面通过 props接收父组件传过来的数据*/ import Header from &apos;./Header.vue&apos;; export default&#123; data()&#123; return &#123; msg:&apos;我是一个home组件&apos;, title:&apos;首页111&apos; &#125; &#125;, components:&#123; &apos;v-header&apos;:Header &#125;, methods:&#123; run(data)&#123; alert(&apos;我是Home组件的run方法&apos;+data); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; /*css 局部作用域 scoped*/ h2&#123; color:red &#125; &lt;/style&gt; 接下来在子组件中使用变量，在props中接收123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是头部组件--&#123;&#123;title&#125;&#125;---&#123;&#123;homemsg&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;run(&apos;123&apos;)&quot;&gt;执行父组件的方法&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;button @click=&quot;getParent()&quot;&gt;获取父组件的数据和方法&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; msg:&apos;子组件的msg&apos; &#125; &#125;, methods:&#123; getParent()&#123; // alert(this.title) // alert(this.home.title) this.home.run() &#125; &#125;, props:[&apos;title&apos;,&apos;homemsg&apos;,&apos;run&apos;,&apos;home&apos;] &#125;&lt;/script&gt; 还可以对父组件传递过来的值验证，不是这种类型就不接受，控制台报错，在子组件接受传递过来的props中设置 12345props:&#123; title:String, getParent:Function, getHome:Function &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[github_git]]></title>
    <url>%2F2019%2F05%2F05%2Fgithub-git%2F</url>
    <content type="text"><![CDATA[远程仓库 搭建github就不说了，进入(仓库主页)创建仓库，仓库主页在哪?可以在右上角的your repositories，或者在个人主页(your profile)里面有repositories，点一下就是仓库主页。 在里面创建一个仓库，作为远程仓库。创建完之后，是个空仓库。有个提示，在本地可以用以下命令：12345git initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/pcdegithub/learn.git //这就是本地建立与远程仓库的连接git push -u origin master 这样就把本地仓库与远程仓库建立了联系，同时，把本地仓库所有内容推送到远程仓库。 如果本地有仓库了，那么就不用再git init初始化一个本地仓库，直接将git remote add origin ssh 远程库的名字就是origin，这是Git默认的叫法。也可以改成别的，但是origin这个名字一看就知道是远程库。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以就可以不用加-u 如果不想用git clone https://github.com/pcdegithub/learn.git，而是本地git init后，想直接从github上获取仓库版本然后修改， 123git init git remote add origin https://github.com/pcdegithub/learn.git //这就是本地建立与远程仓库的连接git pull/fetch origin master 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。]]></content>
  </entry>
  <entry>
    <title><![CDATA[learngit]]></title>
    <url>%2F2019%2F05%2F04%2Fgit%2F</url>
    <content type="text"><![CDATA[温习一下git 一、基本命令 git init&nbsp;&nbsp;初始化仓库，在本地创建一个仓库，.git记载了版本等信息. git add file&nbsp;&nbsp;file就是要add的文件名，都是同样的做法，将文件放到暂存区（缓存区），然后一次性提交 git add file1; git add file2;git commit -m “一次性提交” git commit -m “description”&nbsp;&nbsp;-m一定要写，方便以后回退查看历史 git status &nbsp;&nbsp;查看仓库的目前状态。如果仓库来了个新人（创建一个文件），实习期，并没有转正，没交入职材料，没签合同，没录入公司员工管理系统。这时处于未跟踪状态。 &nbsp;&nbsp;当git add放到缓存中之后，意味通过实习期，开始跟踪了。此时看git status ,准备提交 &nbsp;&nbsp;只要执行一次git add，就是通过实习期,后面 无论什么时候修改文件, git status ,是（not staged for commited）将提交暂存区（起点） 总结：有两条路：未跟踪和将提交缓存区本质是一个意思，未跟踪也是将要提交缓存区，然后变为跟踪 untracked–&gt;to be commited not staged to commit(将提交暂存区) —&gt;to be commited 为什么有两个状态,因为git会 add –commit这一路认为add好后就提交,这只会有一个状态，如果中间有修改了，那么会有另一个状态。下面的图状态发生在git add之后，第一个状态就是默认会提交状态，第二个状态是git add之后又修改了内容（缓存内容变了），所以又回到起点，这时只有先git add重新放回缓存里， 其他重要命令 git diff查看不同 无论是新文件 git add 之后修改，还是老文件git add 之前 之后 。总之在未commted之前，都可以看到当前修改的内容和上个内容。无论提交还是修改都要git add放到缓存区，然后一次性提交。staged:暂存，not staged to commit:还没有提交暂存 git reset –HEAD(这里的写法:HEAD^,HEAD^^,HEAD^^^,或者HEAD~100) HEAD^回退到上一个版本，HEAD^^回退到上上个版本……回退之后工作区内容就彻底变了。 git log查看历史纪录，每个历史纪录在git中叫做commit,相当于快照图片中的每条记录名称叫commit，后面是commit的id号，用来回退，之需要输入前几个，git自动识别后面的。Head就是当前版本，指针总是指向head,开始回退： git reset –hard HEAD^ 回退到上一个版本。用git log查看历史纪录，回退之前的版本的记录就没有了。HEAD^这种写法只能回退，不能从过去返回到现在。这时需要commit id了。git reset –hard commitid 只需要写前几位。这个commitid因为查看不到历史纪录，只能用另一个命令 git reflog查看命令历史，以便确定要回到未来的哪个版本。git log可以查看提交历史,只能看到当前版本之前的历史纪录，以便确定要回退到哪个版本。 不管处在什么阶段 ，只要git reset 都直接回退到那个版本，工作区处于无状态即git status查看只会看到nothing to commit, working tree clean 无论git log ,git reflog查看历史纪录，每个版本动作操作都记录下了，包括回退。从上到下是最近操作到过去操作 工作区和暂存区默认工作区是不包含.git文件夹的，默认的状态，没有修改处于没有对工作区做任何修改，那么工作区就是“干净”123$ git statusOn branch masternothing to commit, working tree clean 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 管理的是修改什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 分析过程 ：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit查看最后的状态：Changes not staged for commit (将要提交到缓存） why?:Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。##撤销git checkout – 文件 撤销修改，该是什么状态就是什么状态，仅仅撤销工作区的修改，对暂存区没影响。git reset 是回退到历史版本，.git中版本库每次commit都有个版本。不管是暂存区还是什么阶段，都直接回退历史版本，然后状态工作区是历史版本，暂存区为空（干净状态） 总结：真正比较的是工作区和版本库中的最新版本，暂存区只是两者的桥梁，仅仅起链接作用。 删除文件直接手动删除，或者rm 文件，这种物理删除，导致工作区和版本库中的最新版本不一致，可以通过git status看到。 如果想删除版本库中的，那么git rm 文件 ，然后git commit -m “描述” 如果想撤销物理删除，git checkout – 文件，工作区文件归位。 如果版本库中该文件版本删除了，那么git checkout就没有用了总结： 对于git add之前，工作区是修改还是删除，都可以“一键还原”， git checkout其实是用版本库里的版本替换工作区的版本。 对于添加到暂存区之后，工作区是修改还是删除，也是一键还原到暂存区该有的状态。如：如果添加到暂存区后，又修改了工作区，这时候删除，用git checkout撤销会撤销到暂存区并且未修改状态。 总之该是什么状态就是什么状态]]></content>
  </entry>
</search>
