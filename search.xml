<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo几个命令]]></title>
    <url>%2F2019%2F12%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue非父子组件传值]]></title>
    <url>%2F2019%2F05%2F12%2Fvue%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[非父子组件传值 1、新建一个js文件 然后引入vue 实例化vue 最后暴露这个实例 2、在要广播的地方引入刚才定义的实例 3、通过 VueEmit.$emit(‘名称’,’数据’) 4、在接收收数据的地方通过 $om接收广播的数据 VueEmit.$on(‘名称’,function(){ })]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue-1]]></title>
    <url>%2F2019%2F05%2F11%2Fvue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[父子组件交互父组件给子组件传值 在父组件中调用子组件中时，绑定动态属性 1&lt;v-header :title="title"&gt;&lt;/v-header&gt; 在子组件中接受传过来的数据有两种表示方式： 通过props直接接收 传过来的属性，如：props:[‘title’] 接收是可以验证父组件传过来的属性，不符报错，如： props:{‘title’:String } 父组件主动获取子组件传值 在父组件中调用子组件中时，定义一个ref1&lt;v-header ref="header"&gt;&lt;/v-header&gt; 在父组件中通过this.$refs.header.子组件属性/方法 看看vue的官方api说明： ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例： 子组件主动获取父组件值 这种是来替代第一种父组件给子组件传值的，通过$parent直接获取父组件的属性和方法。this.$parent.父组件属性/方法看看vue的官方api说明： $parent 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。]]></content>
  </entry>
  <entry>
    <title><![CDATA[angularjs]]></title>
    <url>%2F2019%2F05%2F10%2Fangularjs%2F</url>
    <content type="text"><![CDATA[angularjs学习： 减轻程序员的负担、避免重复劳动 扩展了Html的功能：颠覆性、可扩展 基础 angular是mvc架构。 m 模型—数据 v 视图—-表现层 c 控制—业务逻辑 和其他库共存，ng-app=””表示一个范围，归angular。 双向绑定：l]]></content>
  </entry>
  <entry>
    <title><![CDATA[js—prototype]]></title>
    <url>%2F2019%2F05%2F10%2Fjs%E2%80%94prototype%2F</url>
    <content type="text"><![CDATA[js原型对我以前的研究js原型做一个总结：在刚刚接触JS原型链的时候都会接触到一个熟悉的名词：prototype；如果你曾经深入过prototype，你会接触到另一个名词：proto（注意：两边各有两条下划线，不是一条）。以下将会围绕prototype和proto这两个名词解释为什么不能在原型链上使用对象以及JS原型链的深层原理。 一、为什么不能在原型链上使用对象： 先举一个非常简单的例子，我有一个类叫Humans（人类），然后我有一个对象叫Tom（一个人）和另一个对象叫Merry(另一个人)，很明显Tom和Merry都是由Humans这一个类实例化之后得到的，然后可以把这个例子写成如下代码： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = true; var Tom = new Humans();var Merry = new Humans(); alert(Tom.foot);//结果：2alert(Tom.ability);//结果：truealert(Merry.foot);//结果：2alert(Merry.ability);//结果：true复制代码 以上是一个非常简单的面向对象的例子，相信都能看懂，如果尝试修改Tom的属性ability，则 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = true; var Tom = new Humans();var Merry = new Humans(); Tom.ability = false;alert(Tom.foot);//结果：2alert(Tom.ability);//结果：falsealert(Merry.foot);//结果：2alert(Merry.ability);//结果：true复制代码 以上可以看出Tom的ability属性的值改变了，但并不影响Merry的ability属性的值，这正是我们想要的结果，也是面向对象的好处，由同一个类实例化得到的各个对象之间是互不干扰的；OK，接下来给ability换成object对象又如何?代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability = { run : ‘50米/10秒’, jump : ‘2米’};alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’100米/10秒’alert(Merry.ability.jump); //结果：’3米’复制代码 以上代码就是在原型链上使用了对象，但从以上代码可以看出Tom的ability属性的改变依然丝毫不会影响Merry的ability的属性，于是乎你会觉得这样的做法并无不妥，为什么说不能在原型链上使用对象?接下来的代码就会显得很不一样，并且可以完全表达出原型链上使用对象的危险性： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability.run = ‘50米/10秒’;Tom.ability.jump = ‘2米’; alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’50米/10秒’alert(Merry.ability.jump); //结果：’2米’复制代码 没错，从以上代码的输出结果可以看出Tom的ability属性的改变影响到Merry的ability属性了，于是就可以明白在原型链上使用对象是非常危险的，很容易会打破实例化对象之间的相互独立性，这就是为什么不能在原型链上使用对象的原因?是的，但我想说的可不只如此，而是其中的原理，看完后面JS原型链的深层原理之后，相信你会完全明白。 在以下第二部份解释JS原型链的深层原理之前，先来明确一个概念：原型链上的属性或方法都是被实例化对象共用的，正因如此，上面的Tom.ability.run=’50米/10秒’，改动了原型连上的ability才导致另一个对象Merry受影响，既然如此，你可能会问Tom.ability = {……}不也是改动了原型链上的ability吗，为什么Merry没有受影响?答案是Tom.ability = {……}并没有改动原型链上的ability属性，而是为Tom添加了一个自有属性ability，以后访问Tom.ability的时候不再需要访问原型链上的ability，而是访问其自有属性ability，这是就近原则；OK，如果你仍有疑问，可以用纸笔记下你的疑问，继续往下看你会更加明白。 二、JS原型链的深层原理： 首先要引入一个名词proto，proto是什么?在我的理解里，proto才是真正的原型链，prototype只是一个壳。如果你使用的是chrome浏览器，那么你可以尝试使用alert(Tom.proto.ability.run)，你发现这样的写法完全可行，而且事实上当只有原型链上存在ability属性的时候，Tom.ability其实是指向Tom.proto.ability的；当然，如果你跑到IE浏览器里尝试必然会报错，事实上IE浏览器禁止了对proto的访问，而chrome则是允许的，当然实际开发中，我并不建议直接就使用proto这一属性，但它往往在我们调试代码时发挥着重要作用。有人可能会问到底Tom.proto和Humans.prototype是什么关系，为了理清两者的关系，下面先列出三条法则： 1、对象是拥有proto属性的，但没有prototype；例如：有Tom.proto，但没有Tom.prototype。 2、类没有proto属性，但有prototype；例如：没有Humans.proto，但有Humans.prototype（这里必须纠正一下，同时非常感谢‘川川哥哥’提出这一处错处，确实是我在写到这一点的时候没有考虑清楚，事实上Humans也是Function的一个实例对象，因此Humans.proto===Function.prototype是绝对成立的，稍有特殊的是这时Function.prototype是指向一个Empty（空）函数，值得推敲）。 3、由同一个类实例化（new）得到的对象的proto是引用该类的prototype的（也就是我们说的引用传递）；例如Tom和Merry的proto都引用自Humans的prototype。 OK，上面说过Tom.ability={……}其实并没有改变原型链上的ability属性，或者说并没有改变Tom.proto.ability，而是为Tom添加了一个自有的ability属性，为了说明这一点，我们再次回到以上的第三个代码块，其代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability = { run : ‘50米/10秒’, jump : ‘2米’};alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’100米/10秒’alert(Merry.ability.jump); //结果：’3米’复制代码 当为Tom.ability赋予新的值后，再次访问Tom.ability时就不再指向Tom.proto.ability了，因为这时其实是为Tom添加了自有属性ability，可以就近取值了，你可以尝试用Chrome浏览器分别alert(Tom.ability.run)和alert(Tom.proto.ability.run)，你会发现确实存在两个不同的值，再看完下面的图后，相信你会完全明白： 于是可以有这样一个结论：当访问一个对象的属性或方法的时候，如果对象本身有这样一个属性或方法就会取其自身的属性或方法，否则会尝试到原型链（proto）上寻找同名的属性或方法。明白了这一点后，要解释以上第四个代码块的原理也非常容易了，其代码如下： 复制代码function Humans() { this.foot = 2;}Humans.prototype.ability = { run : ‘100米/10秒’, jump : ‘3米’}; var Tom = new Humans();var Merry = new Humans(); Tom.ability.run = ‘50米/10秒’;Tom.ability.jump = ‘2米’; alert(Tom.ability.run); //结果：’50米/10秒’alert(Tom.ability.jump); //结果：’2米’alert(Merry.ability.run); //结果：’50米/10秒’alert(Merry.ability.jump); //结果：’2米’复制代码 当Tom.ability.run=’50米/10秒’的时候，JS引擎会认为Tom.ability是存在的，因为有Tom.ability才会有Tom.ability.run，所以引擎开始寻找ability属性，首先是会从Tom的自有属性里寻找，在自有属性里并没有找到，于是到原型链里找，结果找到了，于是Tom.ability就指向了Tom.proto.ability了，修改Tom.ability.run的时候实际上就是修改了原型链上的ability了，因而影响到了所有由Humans实例化得到的对象，如下图： 希望上面所讲的内容足够清楚明白，下面通过类的继承对原型链作更进一步的深入： 先来看一个类的继承的例子，代码如下： 复制代码function Person() { this.hand = 2; this.foot = 2;}Person.prototype.say = function () { alert(‘hello’);}function Man() { Person.apply(this, arguments);//对象冒充 this.head = 1;}Man.prototype = new Person();//原型链Man.prototype.run = function () { alert(‘I am running’);};Man.prototype.say = function () { alert(‘good byte’);}var man1 = new Man();复制代码 以上代码是使用对象冒充和原型链相结合的混合方法实现类的继承，也是目前JS主流的实现类的继承的方法，如果对这种继承方法缺乏了解，可以看看这里。 接下来看看以上实现继承后的原型链，可以运用prototype和proto来解释其中的原理： 1、从man1 = new Man()，可以知道man1的proto是指向Man.prototype的，于是有: 公式一：man1.proto === Man.prototype 为true 2、从上面的代码原型链继承里面看到这一句代码 Man.prototype = new Person()，作一个转换，变成：Man.prototype = a，a = new Perosn()；一个等式变成了两个等式，于是由a = new Perosn()可以推导出a.proto = Person.prototype，结合Man.prototype = a，于是可以得到： 公式二：Man.prototype.proto === Person.prototype 为true 由公式一和公式二我们就得出了以下结论： 公式三：man1.proto.proto === Person.prototype 为true 公式三就是上述代码的原型链，有兴趣的话，可以尝试去推导多重继承的原型链，继承得越多，你会得到一个越长的原型链，而这就是原型链的深层原理；从公式三可以得出一个结论：当你访问一个对象的属性或方法时，会首先在自有属性寻找（man1），如果没有则到原型链找，如果在链上的第一环（第一个proto）没找到，则到下一环找（下一个proto），直到找到为止，如果到了原型链的尽头仍没找到则返回undefined（这里必须补充一点：同时非常感谢深蓝色梦想提出的疑问：尽头不是到了Object吗?是的，原型链的尽头就是Object，如果想问为什么，不妨做一个小小的实验：如果指定Object.prototype.saySorry = ‘I am sorry’，那么你会惊喜地发现alert(man1.saySorry)是会弹出结果‘I am sorry’的）。 以上就是原型链的深层原理，说难其实也算容易，如果细心研究，会发现原型链上有很多惊喜。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue]]></title>
    <url>%2F2019%2F05%2F09%2Fvue%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%E5%AD%90%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue的父子传值（包括父组件，值，方法）vue的父组件传递给子组件，两步走：在父组件中：1、导入子组件（这是成为父子组件前提）2、components中申明组件3、view中引用4、引用中引入传递的变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;template&gt; &lt;!-- 所有的内容要被根节点包含起来 --&gt; &lt;div id=&quot;home&quot;&gt; &lt;v-header :title=&quot;title&quot; :homemsg=&apos;msg&apos; :run=&quot;run&quot; :home=&quot;this&quot;&gt;&lt;/v-header&gt; &lt;hr&gt; 首页组件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;/*父组件给子组件传值 1.父组件调用子组件的时候 绑定动态属性 &lt;v-header :title=&quot;title&quot;&gt;&lt;/v-header&gt; 2、在子组件里面通过 props接收父组件传过来的数据*/ import Header from &apos;./Header.vue&apos;; export default&#123; data()&#123; return &#123; msg:&apos;我是一个home组件&apos;, title:&apos;首页111&apos; &#125; &#125;, components:&#123; &apos;v-header&apos;:Header &#125;, methods:&#123; run(data)&#123; alert(&apos;我是Home组件的run方法&apos;+data); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; /*css 局部作用域 scoped*/ h2&#123; color:red &#125; &lt;/style&gt; 接下来在子组件中使用变量，在props中接收123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;template&gt; &lt;div&gt; &lt;h2&gt;我是头部组件--&#123;&#123;title&#125;&#125;---&#123;&#123;homemsg&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;run(&apos;123&apos;)&quot;&gt;执行父组件的方法&lt;/button&gt; &lt;br /&gt; &lt;br /&gt; &lt;button @click=&quot;getParent()&quot;&gt;获取父组件的数据和方法&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; msg:&apos;子组件的msg&apos; &#125; &#125;, methods:&#123; getParent()&#123; // alert(this.title) // alert(this.home.title) this.home.run() &#125; &#125;, props:[&apos;title&apos;,&apos;homemsg&apos;,&apos;run&apos;,&apos;home&apos;] &#125;&lt;/script&gt; 还可以对父组件传递过来的值验证，不是这种类型就不接受，控制台报错，在子组件接受传递过来的props中设置 12345props:&#123; title:String, getParent:Function, getHome:Function &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[github_git]]></title>
    <url>%2F2019%2F05%2F05%2Fgithub-git%2F</url>
    <content type="text"><![CDATA[远程仓库 搭建github就不说了，进入(仓库主页)创建仓库，仓库主页在哪?可以在右上角的your repositories，或者在个人主页(your profile)里面有repositories，点一下就是仓库主页。 在里面创建一个仓库，作为远程仓库。创建完之后，是个空仓库。有个提示，在本地可以用以下命令：12345git initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/pcdegithub/learn.gitgit push -u origin master 这样就把本地仓库与远程仓库建立了联系，同时，把本地仓库所有内容推送到远程仓库。 如果本地有仓库了，那么就不用再git init初始化一个本地仓库，直接将git remote add origin ssh 远程库的名字就是origin，这是Git默认的叫法。也可以改成别的，但是origin这个名字一看就知道是远程库。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以就可以不用加-u 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。]]></content>
  </entry>
  <entry>
    <title><![CDATA[learngit]]></title>
    <url>%2F2019%2F05%2F04%2Flearngit%2F</url>
    <content type="text"><![CDATA[温习一下git 一、基本命令 git init&nbsp;&nbsp;初始化仓库，在本地创建一个仓库，.git记载了版本等信息. git add file&nbsp;&nbsp;file就是要add的文件名，都是同样的做法，将文件放到暂存区（缓存区），然后一次性提交 git add file1; git add file2;git commit -m “一次性提交” git commit -m “description”&nbsp;&nbsp;-m一定要写，方便以后回退查看历史 git status &nbsp;&nbsp;查看仓库的目前状态。如果仓库来了个新人（创建一个文件），实习期，并没有转正，没交入职材料，没签合同，没录入公司员工管理系统。这时处于未跟踪状态。 &nbsp;&nbsp;当git add放到缓存中之后，意味通过实习期，开始跟踪了。此时看git status ,准备提交 &nbsp;&nbsp;只要执行一次git add，就是通过实习期,后面 无论什么时候修改文件, git status ,是（not staged for commited）将提交暂存区（起点） 总结：有两条路：未跟踪和将提交缓存区本质是一个意思，未跟踪也是将要提交缓存区，然后变为跟踪 untracked–&gt;to be commited not staged to commit(将提交暂存区) —&gt;to be commited 为什么有两个状态,因为git会 add –commit这一路认为add好后就提交,这只会有一个状态，如果中间有修改了，那么会有另一个状态。下面的图状态发生在git add之后，第一个状态就是默认会提交状态，第二个状态是git add之后又修改了内容（缓存内容变了），所以又回到起点，这时只有先git add重新放回缓存里， 其他重要命令 git diff查看不同 无论是新文件 git add 之后修改，还是老文件git add 之前 之后 。总之在未commted之前，都可以看到当前修改的内容和上个内容。无论提交还是修改都要git add放到缓存区，然后一次性提交。staged:暂存，not staged to commit:还没有提交暂存 git reset –HEAD(这里的写法:HEAD^,HEAD^^,HEAD^^^,或者HEAD~100) HEAD^回退到上一个版本，HEAD^^回退到上上个版本……回退之后工作区内容就彻底变了。 git log查看历史纪录，每个历史纪录在git中叫做commit,相当于快照图片中的每条记录名称叫commit，后面是commit的id号，用来回退，之需要输入前几个，git自动识别后面的。Head就是当前版本，指针总是指向head,开始回退： git reset –hard HEAD^ 回退到上一个版本。用git log查看历史纪录，回退之前的版本的记录就没有了。HEAD^这种写法只能回退，不能从过去返回到现在。这时需要commit id了。git reset –hard commitid 只需要写前几位。这个commitid因为查看不到历史纪录，只能用另一个命令 git reflog查看命令历史，以便确定要回到未来的哪个版本。git log可以查看提交历史,只能看到当前版本之前的历史纪录，以便确定要回退到哪个版本。 不管处在什么阶段 ，只要git reset 都直接回退到那个版本，工作区处于无状态即git status查看只会看到nothing to commit, working tree clean 无论git log ,git reflog查看历史纪录，每个版本动作操作都记录下了，包括回退。从上到下是最近操作到过去操作 工作区和暂存区默认工作区是不包含.git文件夹的，默认的状态，没有修改处于没有对工作区做任何修改，那么工作区就是“干净”123$ git statusOn branch masternothing to commit, working tree clean 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 管理的是修改什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 分析过程 ：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit查看最后的状态：Changes not staged for commit (将要提交到缓存） why?:Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。##撤销git checkout – 文件 撤销修改，该是什么状态就是什么状态，仅仅撤销工作区的修改，对暂存区没影响。git reset 是回退到历史版本，.git中版本库每次commit都有个版本。不管是暂存区还是什么阶段，都直接回退历史版本，然后状态工作区是历史版本，暂存区为空（干净状态） 总结：真正比较的是工作区和版本库中的最新版本，暂存区只是两者的桥梁，仅仅起链接作用。 删除文件直接手动删除，或者rm 文件，这种物理删除，导致工作区和版本库中的最新版本不一致，可以通过git status看到。 如果想删除版本库中的，那么git rm 文件 ，然后git commit -m “描述” 如果想撤销物理删除，git checkout – 文件，工作区文件归位。 如果版本库中该文件版本删除了，那么git checkout就没有用了总结： 对于git add之前，工作区是修改还是删除，都可以“一键还原”， git checkout其实是用版本库里的版本替换工作区的版本。 对于添加到暂存区之后，工作区是修改还是删除，也是一键还原到暂存区该有的状态。如：如果添加到暂存区后，又修改了工作区，这时候删除，用git checkout撤销会撤销到暂存区并且未修改状态。 总之该是什么状态就是什么状态]]></content>
  </entry>
</search>
