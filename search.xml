<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo几个命令]]></title>
    <url>%2F2019%2F12%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learngit]]></title>
    <url>%2F2019%2F05%2F04%2Flearngit%2F</url>
    <content type="text"><![CDATA[温习一下git 一、基本命令 git init&nbsp;&nbsp;初始化仓库，在本地创建一个仓库，.git记载了版本等信息. git add file&nbsp;&nbsp;file就是要add的文件名，都是同样的做法，将文件放到暂存区（缓存区），然后一次性提交 git add file1; git add file2;git commit -m “一次性提交” git commit -m “description”&nbsp;&nbsp;-m一定要写，方便以后回退查看历史 git status &nbsp;&nbsp;查看仓库的目前状态。如果仓库来了个新人（创建一个文件），实习期，并没有转正，没交入职材料，没签合同，没录入公司员工管理系统。这时处于未跟踪状态。 &nbsp;&nbsp;当git add放到缓存中之后，意味通过实习期，开始跟踪了。此时看git status ,准备提交 &nbsp;&nbsp;只要执行一次git add，就是通过实习期,后面 无论什么时候修改文件, git status ,是（not staged for commited）将提交暂存区（起点） 总结：有两条路：未跟踪和将提交缓存区本质是一个意思，未跟踪也是将要提交缓存区，然后变为跟踪 untracked–&gt;to be commited not staged to commit(将提交暂存区) —&gt;to be commited 为什么有两个状态,因为git会 add –commit这一路认为add好后就提交,这只会有一个状态，如果中间有修改了，那么会有另一个状态。下面的图状态发生在git add之后，第一个状态就是默认会提交状态，第二个状态是git add之后又修改了内容（缓存内容变了），所以又回到起点，这时只有先git add重新放回缓存里， 其他重要命令 git diff查看不同 无论是新文件 git add 之后修改，还是老文件git add 之前 之后 。总之在未commted之前，都可以看到当前修改的内容和上个内容。无论提交还是修改都要git add放到缓存区，然后一次性提交。 git reset –HEAD(这里的写法:HEAD^,HEAD^^,HEAD^^^,或者HEAD~100) HEAD^回退到上一个版本，HEAD^^回退到上上个版本……回退之后工作区内容就彻底变了。]]></content>
  </entry>
</search>
