<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo几个命令]]></title>
    <url>%2F2019%2F12%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github_git]]></title>
    <url>%2F2019%2F05%2F05%2Fgithub-git%2F</url>
    <content type="text"><![CDATA[远程仓库 搭建github就不说了，进入(仓库主页)创建仓库，仓库主页在哪?可以在右上角的your repositories，或者在个人主页(your profile)里面有repositories，点一下就是仓库主页。 在里面创建一个仓库，作为远程仓库。创建完之后，是个空仓库。有个提示，在本地可以用以下命令：12345git initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/pcdegithub/learn.gitgit push -u origin master 这样就把本地仓库与远程仓库建立了联系，同时，把本地仓库所有内容推送到远程仓库。 如果本地有仓库了，那么就不用再git init初始化一个本地仓库，直接将git remote add origin ssh 远程库的名字就是origin，这是Git默认的叫法。也可以改成别的，但是origin这个名字一看就知道是远程库。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以就可以不用加-u 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。]]></content>
  </entry>
  <entry>
    <title><![CDATA[learngit]]></title>
    <url>%2F2019%2F05%2F04%2Flearngit%2F</url>
    <content type="text"><![CDATA[温习一下git 一、基本命令 git init&nbsp;&nbsp;初始化仓库，在本地创建一个仓库，.git记载了版本等信息. git add file&nbsp;&nbsp;file就是要add的文件名，都是同样的做法，将文件放到暂存区（缓存区），然后一次性提交 git add file1; git add file2;git commit -m “一次性提交” git commit -m “description”&nbsp;&nbsp;-m一定要写，方便以后回退查看历史 git status &nbsp;&nbsp;查看仓库的目前状态。如果仓库来了个新人（创建一个文件），实习期，并没有转正，没交入职材料，没签合同，没录入公司员工管理系统。这时处于未跟踪状态。 &nbsp;&nbsp;当git add放到缓存中之后，意味通过实习期，开始跟踪了。此时看git status ,准备提交 &nbsp;&nbsp;只要执行一次git add，就是通过实习期,后面 无论什么时候修改文件, git status ,是（not staged for commited）将提交暂存区（起点） 总结：有两条路：未跟踪和将提交缓存区本质是一个意思，未跟踪也是将要提交缓存区，然后变为跟踪 untracked–&gt;to be commited not staged to commit(将提交暂存区) —&gt;to be commited 为什么有两个状态,因为git会 add –commit这一路认为add好后就提交,这只会有一个状态，如果中间有修改了，那么会有另一个状态。下面的图状态发生在git add之后，第一个状态就是默认会提交状态，第二个状态是git add之后又修改了内容（缓存内容变了），所以又回到起点，这时只有先git add重新放回缓存里， 其他重要命令 git diff查看不同 无论是新文件 git add 之后修改，还是老文件git add 之前 之后 。总之在未commted之前，都可以看到当前修改的内容和上个内容。无论提交还是修改都要git add放到缓存区，然后一次性提交。staged:暂存，not staged to commit:还没有提交暂存 git reset –HEAD(这里的写法:HEAD^,HEAD^^,HEAD^^^,或者HEAD~100) HEAD^回退到上一个版本，HEAD^^回退到上上个版本……回退之后工作区内容就彻底变了。 git log查看历史纪录，每个历史纪录在git中叫做commit,相当于快照图片中的每条记录名称叫commit，后面是commit的id号，用来回退，之需要输入前几个，git自动识别后面的。Head就是当前版本，指针总是指向head,开始回退： git reset –hard HEAD^ 回退到上一个版本。用git log查看历史纪录，回退之前的版本的记录就没有了。HEAD^这种写法只能回退，不能从过去返回到现在。这时需要commit id了。git reset –hard commitid 只需要写前几位。这个commitid因为查看不到历史纪录，只能用另一个命令 git reflog查看命令历史，以便确定要回到未来的哪个版本。git log可以查看提交历史,只能看到当前版本之前的历史纪录，以便确定要回退到哪个版本。 不管处在什么阶段 ，只要git reset 都直接回退到那个版本，工作区处于无状态即git status查看只会看到nothing to commit, working tree clean 无论git log ,git reflog查看历史纪录，每个版本动作操作都记录下了，包括回退。从上到下是最近操作到过去操作 工作区和暂存区默认工作区是不包含.git文件夹的，默认的状态，没有修改处于没有对工作区做任何修改，那么工作区就是“干净”123$ git statusOn branch masternothing to commit, working tree clean 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 管理的是修改什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 分析过程 ：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit查看最后的状态：Changes not staged for commit (将要提交到缓存） why?:Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 总结：不管处于什么阶段：add前后或者commit前后，工作区是物理磁盘，暂存区是缓存，不是一回事。工作区修改，暂存区不会变，提交都是经过缓存。所以只要工作区修改，都要add到缓存区。##撤销git checkout – 文件 撤销修改，该是什么状态就是什么状态，仅仅撤销工作区的修改，对暂存区没影响。git reset 是回退到历史版本，.git中版本库每次commit都有个版本。不管是暂存区还是什么阶段，都直接回退历史版本，然后状态工作区是历史版本，暂存区为空（干净状态） 总结：真正比较的是工作区和版本库中的最新版本，暂存区只是两者的桥梁，仅仅起链接作用。 删除文件直接手动删除，或者rm 文件，这种物理删除，导致工作区和版本库中的最新版本不一致，可以通过git status看到。 如果想删除版本库中的，那么git rm 文件 ，然后git commit -m “描述” 如果想撤销物理删除，git checkout – 文件，工作区文件归位。 如果版本库中该文件版本删除了，那么git checkout就没有用了总结： 对于git add之前，工作区是修改还是删除，都可以“一键还原”， git checkout其实是用版本库里的版本替换工作区的版本。 对于添加到暂存区之后，工作区是修改还是删除，也是一键还原到暂存区该有的状态。如：如果添加到暂存区后，又修改了工作区，这时候删除，用git checkout撤销会撤销到暂存区并且未修改状态。 总之该是什么状态就是什么状态]]></content>
  </entry>
</search>
